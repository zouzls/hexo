---
title: 深入理解JVM之Java内存模型（三）
date: 2016-10-17 15:59:37
tags:
  - JVM
  - JMM
categories: JVM
---
**Java内存模型的主要目标是定义程序中的各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。**此处的变量跟java编程中的变量有一定的区别，它包括实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然不存在竞争问题。
<!--more-->
### 主内存和工作内存
这里说的主内存和java内存区域中的java堆、栈、方法区并不是一个同一个层次的内存划分，基本没有关系。如果非要对应起来，主内存应该对应于java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。
![](http://img.blog.csdn.net/20130523001112026)
上图是Java虚拟机运行时数据区，可以看到虚拟机栈是线程隔离的区域，即线程私有，java堆是所有线程共享的。
再次回到主内存和工作内存，Java内存模型规定了所有变量都存储在主内存中，每条线程有自己的工作内存，线程的工作内存保存了被该线程用到的变量的主内存副本拷贝，线程对变量所有的操作都必须在工作内存中进行，而不能直接读写主内存中的变量，不同的线程间变量值的传递均需要通过主内存来完成。线程、主内存、工作内存三者关系如下图：
![](http://7xisp0.com1.z0.glb.clouddn.com/jvm_mem_model_relationship.png)

### 内存间交互操作
关于主内存和工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步会主内存之类的细节。JMM定义了8种操作来完成，虚拟机实现时必须保证每一种操作都是原子的不可再分的。
如果把一个变量从主内存复制到工作内存，就要顺序执行read和load操作，如果要把变量从工作内存同步回主内存，就要顺序执行store和write操作。注意，java内存模型只要求上述两个操作必须按顺序执行，而且没有保证是连续执行。除此之外，java内存模型还规定了在执行8种操作必须满足的规则，但是这种规则繁琐麻烦，后面等效判断的「先行发生原则」可以同样来确定一个访问在并发环境下是否安全。

### 对于volatile型变量的特殊规则
关键字volatile可以说是java虚拟机提供的最轻量级的同步机制。当一个变量定义为volatile之后，它将具备两种特性：
#### 保证变量对所有线程的可见性
这里的可见性是指当一条线程修改了这个变量的值，新值对其他线程来说是可以立即得知的。**Volatile 变量具有 synchronized 的可见性特性，但是不具备原子特性。**这就是说线程能够自动发现 volatile 变量的最新值。Volatile 变量可用于提供线程安全，但是只能应用于非常有限的一组用例：多个变量之间或者某个变量的当前值与修改后值之间没有约束。因此，单独使用 volatile 还不足以实现计数器、互斥锁或任何具有与多个变量相关的不变式（Invariants）的类（例如 “start <=end”）。您只能在有限的一些情形下使用 volatile 变量替代锁。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：
- 对变量的写操作不依赖于当前值。
- 该变量没有包含在具有其他变量的不变式中。

实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。第一个条件的限制使 volatile 变量不能用作线程安全计数器。虽然增量操作（x++）看上去类似一个单独操作，实际上它是一个由读取－修改－写入操作序列组成的组合操作，必须以原子方式执行，而 volatile 不能提供必须的原子特性。实现正确的操作需要使 x 的值在操作期间保持不变，而 volatile 变量无法实现这点。（然而，如果将值调整为只从单个线程写入，那么可以忽略第一个条件。）
**要始终牢记使用 volatile 的限制 —— 只有在状态真正独立于程序内其他内容时才能使用 volatile —— 这条规则能够避免将这些模式扩展到不安全的用例。**其中一种典型的模式应用就是将 volatile 变量作为状态标志使用，很多应用程序包含了一种控制结构，形式为 “在还没有准备好停止程序时再执行一些工作”，如下列代码所示：
```java
    volatile boolean shutdownRequested;
    ...
    public void shutdown() { shutdownRequested = true; }

    public void doWork() { 
        while (!shutdownRequested) { 
            // do stuff
        }
    }
```
很可能会从循环外部调用 shutdown() 方法 —— 即在另一个线程中 —— 因此，需要执行某种同步来确保正确实现 shutdownRequested 变量的可见性。由于 volatile简化了编码，并且状态标志并不依赖于程序内任何其他状态，因此此处非常适合使用 volatile。

#### 禁止指令重排
使用volatile的第二个语义是禁止指令重排，普通的变量仅仅会保证在该方法执行过程中所有依赖赋值结果的地方都能取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在一个线程的方法执行过程中无法感知到这点，这就是JMM中所谓的“线程内表现为串行的语义”，举例代码如下：
```java 
    //全局变量
    volatile boolean open=true;
    //线程A
    resource.close();
    open = false;
    //线程B
    while(open) {
        doSomethingWithResource(resource);
    }
```
如果定义open变量没有使用volatile修饰，就可能由于指令重排的优化，导致线程A最后一句的代码被提前执行。

解决了volatile的语义问题，再来看看在众多保障并发安全的工具中选用volatile的意图——它能让我们的代码更快吗？在某些情况下，volatile的同步机制的性能确实要优于锁，但是优于虚拟机对锁实行的许多优化和消除，使我们很难认为volatile就会比synchronized快多少。但是我们可以确定volatile的读操作性能与普通变量没啥区别，写操作要慢些，因为它要在本地代码中插入许多内存屏障来保证处理器不发生乱序执行。我们在volatile和锁之间选择的唯一依据仅仅是volatile的语义能否适用场景的需求。

### 先行发生原则「Happends-Before」
这个原则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据。先行发生是JMM中定义两项操作的偏序关系，如果操作A先行发生于操作B，则说明操作A产生的影响一定能被B观察到。下面是JMM中天然的先行发生关系，这些先行发生关系无需任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则中推导出来，它们就没有顺序保障，虚拟机可以对它们随意进行重排序。
- 程序次序规则：在一个线程内，按照代码顺序（准确的说是控制流顺序），书写在前面的操作先于后面的操作。
- 管程锁定规则
- volatile变量：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的后面就是“时间”的先后顺序。
- 线程启动规则
- 线程终止规则
- 线程中断规则
- 对象终结规则
- 传递性

举例代码如下：
```java
    private int value=0;
    public void setValue(int value){
        this.value=value;
    }
    public int getValue(){
        return value;
    }
```
其中，线程A先调用了一个对象的setValue(1)，然后线程B调用了同一个对象的getValue()，那么线程B收到的返回值是什么？
如果对照上述的先行发生规则，该案例操作不符合任意条规则，所以这里面的操作不是安全的。
那么怎么修复这个问题？有两个方案可以选择，要么是对getter、setter方法定义为synchronized方法，这样就可以套用官程锁定规则；要么把value定义为volatile变量，由于setter对value的修改不依赖value的原值，满足volatile的场景，这样也可以套用volatile变量规则来实现先行发生关系。通过上面的例子，可以得出：一个操作“时间上的先发生”不代表这个操作会是“先行发生”。
那如果一个操作是满足先行发生关系，是不是就能推导出这个操作必定是时间上先发生呢？示例代码如下：
```java
    //同一线程中
    int i=1;
    int j=2;
```
结论是不成立的，因为由于指令重排，int j=2完全有可能先被执行，但是并不影响先行发生的准确性。上面两个例子证明了：时间先后顺序和先行发生原则关系并不太大，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生规则为准。

-EOF-



