<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gs Chen&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zouzls.github.io/"/>
  <updated>2016-11-24T17:19:26.100Z</updated>
  <id>https://zouzls.github.io/</id>
  
  <author>
    <name>Gs Chen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>通往C++之路</title>
    <link href="https://zouzls.github.io/2016/11/25/%E9%80%9A%E5%BE%80C-%E4%B9%8B%E8%B7%AF/"/>
    <id>https://zouzls.github.io/2016/11/25/通往C-之路/</id>
    <published>2016-11-24T16:47:51.000Z</published>
    <updated>2016-11-24T17:19:26.100Z</updated>
    
    <content type="html">&lt;p&gt;最近在准备看看LevelDB的源码，因为它是一个写入性能高效的基于硬盘的K-V键值存储，区别于Redis这种基于内存的键值对存储数据库，仅仅知道它是以LSM-Tree数据结构实现而成并不能满足我的好奇心，果断还是想一窥LevelDB的庐山真面目，但是它毕竟又是以CPP写的，这给我这种之前长期驻扎Java为阵营的成员还是带来了不少的学习成本，但是个人觉得语言永远应该不能成为阻挡你理解计算机世界的拦路虎。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;思索再三，Java凭借JVM的强大带来自身编码效率和安全性的提升在包括Web的很多领域确实是一把利器，但是要想在存储或者数据库领域撬起一块砖头，还是需要CPP这把短刃的。&lt;/p&gt;
&lt;p&gt;有过面向对象和C的基础，踏上的CPP的道路应该不会太难，这篇文章会记录在CPP学习过程中的一些觉得不错的文章资料总结或者心得。当然学习语言并不是目的，而是应该成为解决问题的工具。&lt;/p&gt;
&lt;p&gt;查阅文章资料如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.runoob.com/cplusplus/cpp-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;C++简易教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/shelvenn/archive/2008/02/02/1062446.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;.h和.cpp文件的区别&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文会随着学习情况逐渐更新。&lt;/p&gt;
&lt;p&gt;-EOF-&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近在准备看看LevelDB的源码，因为它是一个写入性能高效的基于硬盘的K-V键值存储，区别于Redis这种基于内存的键值对存储数据库，仅仅知道它是以LSM-Tree数据结构实现而成并不能满足我的好奇心，果断还是想一窥LevelDB的庐山真面目，但是它毕竟又是以CPP写的，这给我这种之前长期驻扎Java为阵营的成员还是带来了不少的学习成本，但是个人觉得语言永远应该不能成为阻挡你理解计算机世界的拦路虎。&lt;br&gt;
    
    </summary>
    
      <category term="C++" scheme="https://zouzls.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://zouzls.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>存储引擎技术之LSM Tree</title>
    <link href="https://zouzls.github.io/2016/11/23/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF%E4%B9%8BLSM%20Tree/"/>
    <id>https://zouzls.github.io/2016/11/23/存储引擎技术之LSM Tree/</id>
    <published>2016-11-23T07:56:27.000Z</published>
    <updated>2016-11-23T13:12:13.329Z</updated>
    
    <content type="html">&lt;p&gt;一直觉得数据库内部的实现是个黑匣子，总感觉很神秘，借着前段时间「海量存储」这门课程课堂报告的机会，读了一些Paper，虽然没能全部仔细读完，但是从每篇Paper的Abstract里面还是能窥见当前领域的近来的一些学术动态，很多东西没能记住，但是，印象唯独深刻的是，几乎大部分paper都在讨论：如何使得存储系统的I/O性能更快更有效率，如何使得同样的物理存储能够存储更多的数据内容？&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;前话&quot;&gt;&lt;a href=&quot;#前话&quot; class=&quot;headerlink&quot; title=&quot;前话&quot;&gt;&lt;/a&gt;前话&lt;/h3&gt;&lt;p&gt;在这一点上，其实是让我开始觉得计算机领域无非就是「存储+计算」，从冯-诺依曼时代就是如此。最后我选择了&lt;a href=&quot;https://www.usenix.org/node/170855&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Spanner&lt;/a&gt;这篇论文作为了自己的课程报告，原因是它的Abstract太吸引我了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Spanner is Google’s scalable, multi-version, globally distributed, and synchronously-replicated database. &lt;strong&gt;It is the first system to distribute data at global scale and support externally-consistent distributed transactions. &lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然当时是对里面很对的术语multi-version、synchronously-replicated、externally-consistent、 distributed transactions不太清楚，出于对「分布式数据库」中分布式和数据库两个领域的好奇心，还是读下去了，当然现在很多专业术语现在还是并不能完全透彻明白，但是已经open in my mind，对于数据库里面核心的概念「事务」、「并发控制」的理解又加深了一层。这里并不打算讨论spanner相关内容，感兴趣的同学可以自己了解。&lt;/p&gt;
&lt;p&gt;随着对Mysql数据库了解加深，知道Mysql的存储引擎主要是Innodb和MyISAM，前者一般是默认存储引擎，主要是B+Tree的数据结构来组织数据。&lt;br&gt;知道这一点的时候是我第一次能将之前学习的「数据结构」和具体应用领域结合起来，当时感觉是兴奋的，不再觉得学习这些有什么用。&lt;br&gt;我发现很多知识，当第一次出现在你的眼前的时候，往往不会引起你的注意，也根本引起不了你的好奇心，但是接二连三出现在视线时，探索的欲望就来了，比如LSM Tree。本文以LevelDB为例介绍LSM在存储引擎中的实现。&lt;/p&gt;
&lt;h3 id=&quot;LSM的背景&quot;&gt;&lt;a href=&quot;#LSM的背景&quot; class=&quot;headerlink&quot; title=&quot;LSM的背景&quot;&gt;&lt;/a&gt;LSM的背景&lt;/h3&gt;&lt;p&gt;LSM Tree的全名叫做Log Structured-Merge Tree。&lt;br&gt;LSM是当前被用在许多产品的文件结构策略：HBase, Cassandra, LevelDB, SQLite,甚至在mangodb3.0中也带了一个可选的LSM引擎（Wired Tiger 实现的）。&lt;br&gt;简单的说，LSM被设计来提供比传统的B+树或者ISAM更好的写操作吞吐量，通过消去随机的本地更新操作来达到这个目标。&lt;/p&gt;
&lt;p&gt;那么为什么这是一个好的方法呢？这个问题的本质还是磁盘随机操作慢，顺序读写快的老问题。这二种操作存在巨大的差距，无论是磁盘还是SSD。&lt;br&gt;想象一下在「操作系统」里面关于磁盘寻址就能明白，随机读写的效率是非常低的，因为要涉及到频繁的磁道寻址。&lt;/p&gt;
&lt;h3 id=&quot;LevelDB中LSM引擎实现&quot;&gt;&lt;a href=&quot;#LevelDB中LSM引擎实现&quot; class=&quot;headerlink&quot; title=&quot;LevelDB中LSM引擎实现&quot;&gt;&lt;/a&gt;LevelDB中LSM引擎实现&lt;/h3&gt;&lt;h4 id=&quot;LSM的基本思想&quot;&gt;&lt;a href=&quot;#LSM的基本思想&quot; class=&quot;headerlink&quot; title=&quot;LSM的基本思想&quot;&gt;&lt;/a&gt;LSM的基本思想&lt;/h4&gt;&lt;p&gt;lsm tree 是针对写入速度瓶颈问题而提出的. mysql 这种数据库的存储引擎使用了 B+ 树来持久化数据, B+ 树是一个索引树, 可以说是同时考虑了读写均衡, 其结构上对树高进行了优化, 搜索耗时相比 AVL 树降下来. 然而问题依然是前面我们谈到的 “对一个随机读优化的排序结构执行随机写是有很大开销的”, 所以对那些需要高频写操作的系统来讲, B+ 树作为存储结构可能并不合适.&lt;br&gt;这时 lsm tree 可能是个更好的选择, 它是一种类似日志的数据结构, 将随机写变为顺序写, 核心思想是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对变更进行批量 &amp;amp; 延时处理&lt;/li&gt;
&lt;li&gt;通过归并排序将更新迁移到硬盘上&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自从上世纪某年代一篇关于日志结构文件系统的论文发表之后, 有人基于这个想法提出了解决写瓶颈的问题: 使用顺序写(追加)替代随机写. 为什么要变为顺序写呢? 因为顺序写不需要多次寻址, 速度能达到硬盘理论传输速度, 而随机写则受限于硬盘寻址速度.&lt;br&gt;leveldb 在持久化上借鉴了 lsm tree 的设计. 具体实现就是 memtable + sstable.&lt;/p&gt;
&lt;h4 id=&quot;结构规划&quot;&gt;&lt;a href=&quot;#结构规划&quot; class=&quot;headerlink&quot; title=&quot;结构规划&quot;&gt;&lt;/a&gt;结构规划&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/3054411/19015433/dbc1b240-8836-11e6-88e4-67d6b23a3d24.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;根据此图先初步说一下它的读写流程:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;write: 写入 log 文件一条操作(数据更新)记录, 再往 memtable 里写入 k-v 对.&lt;/li&gt;
&lt;li&gt;read: 读 memtable (没找到)→ 读 immutable memtable (没找到)→ 读 sstable (没找到)→ 空&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;memtable&quot;&gt;&lt;a href=&quot;#memtable&quot; class=&quot;headerlink&quot; title=&quot;memtable&quot;&gt;&lt;/a&gt;memtable&lt;/h4&gt;&lt;p&gt;memtable 是个内存数据结构, 也是读写操作的入口.作为一个存储引擎, 读无非就是读若干个 key, 然后返回对应的 value; 而写就是存下这些 key-value 对.&lt;br&gt;所以 memtable 中存的每条数据也都是一个键值对.&lt;br&gt;关键点是 memtable 中的数据是按 key 的字母表顺序排序的.&lt;br&gt;然而对一个具备随机读能力的排序结构执行插入操作往往是有开销的, 通常写瓶颈也都是集中在这里. 但是也有很多数据结构提供了加速随机写, 比如链表, AVL 树, B 树, skiplist. memtable 的核心结构就是用了跳表.&lt;/p&gt;
&lt;p&gt;结构简单, 概率上近似 O(log N) 读写复杂度的跳表在很多存储系统里得到应用, 比如 elasticsearch 的高速搜索就是基于跳表,位图以及倒排索引实现的. memtable 采用这种结构初步实现快速读写.&lt;/p&gt;
&lt;p&gt;接下来, 既然是存储引擎, 那么肯定能持久化数据, 而 leveldb 核心技术就是围绕持久化过程而构建的.&lt;/p&gt;
&lt;h4 id=&quot;sstable&quot;&gt;&lt;a href=&quot;#sstable&quot; class=&quot;headerlink&quot; title=&quot;sstable&quot;&gt;&lt;/a&gt;sstable&lt;/h4&gt;&lt;p&gt;sstable 全名 sort-string table, bigtable 使用的存储技术. 顾名思义, sstable 中的数据都是有序的.&lt;br&gt;除了日志之外, leveldb 的数据统统存储在 sstable 中. sstable主要以block来区分，每个sstable主要包括data block（若干）、index block、footer ，逻辑视图如下所示。&lt;br&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/3054411/19015445/fd244ab0-8836-11e6-961b-6404474941d2.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;下面分别介绍不同种类的block作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;data block&lt;br&gt;存储的是所有的data（k-v）。更具体来说, 是 data 域的 record 段存储的. record 里的 k-v 对全部按 key 有序排列。&lt;/li&gt;
&lt;li&gt;index block&lt;br&gt;index block 中的每条记录会对某个 data block 建立索引.&lt;/li&gt;
&lt;li&gt;footer&lt;br&gt;footer 是整个 sstable 的末尾 block, 记录了 indexblock 的起始偏移量和大小, 很容易看出其存在意义就是为了方便读取 index block.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;sstable与lsm-tree之间的关系&quot;&gt;&lt;a href=&quot;#sstable与lsm-tree之间的关系&quot; class=&quot;headerlink&quot; title=&quot;sstable与lsm tree之间的关系&quot;&gt;&lt;/a&gt;sstable与lsm tree之间的关系&lt;/h4&gt;&lt;p&gt;leveldb 将 sstable 划分为了不同层次(level). level i+1 层的 sstables 由 level i 层的 sstables merge 得来. 而最上层称为 level 0.&lt;/p&gt;
&lt;p&gt;那么第 0 层的 sstables 是怎么来的呢?&lt;/p&gt;
&lt;p&gt;memtable + sstable = lsm tree&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;memtable → immutable memtable (内存中)&lt;/li&gt;
&lt;li&gt;immutable memtable → (level 0) sstable (内存 → 外存)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还记得最开始提到的 memtable? 那个读写入口数据结构. leveldb 给了他一个阈值, 但凡 memtable 里的数据大小达到了阈值, 后台任务就将 memtable 标记为只读, 也就是变成了 immutable memtable.&lt;br&gt;然后创建一个新的 memtable 用于接下来的读写.&lt;/p&gt;
&lt;p&gt;immutable memtable 经过一段时间会被迁移到硬盘上, 成为 sstable, 这一过程称之为 compaction.&lt;br&gt;因为 memtable 的结构是有序的, 因此 sstable 也是有序存储的.&lt;/p&gt;
&lt;h4 id=&quot;Compaction&quot;&gt;&lt;a href=&quot;#Compaction&quot; class=&quot;headerlink&quot; title=&quot;Compaction&quot;&gt;&lt;/a&gt;Compaction&lt;/h4&gt;&lt;p&gt;compaction 是执行 lsm-tree 中 merge 的过程.&lt;br&gt;对于不同应用情况, 分为 minor compaction 和 major compaction.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;minor compaction&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;minor compaction 用于内存到外存的迁移过程. 就是简单的遍历跳表, 依次写入新的 sstable record, 最后建立 index block 并完善一些其他的重要元信息. 这也就是从 immutable memtable 到 level 0 sstable 的迁移.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;major compaction&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;major compaction 用于 level 之间的迁移.&lt;br&gt;当某个 level 的 sstables 数量超过一个给定的阈值, 就会触发 major compaction.&lt;br&gt;这里有两点差异:&lt;/p&gt;
&lt;p&gt;对 level &amp;gt; 0 的 sstables, 选择其中一个 sstable 与 下一层 sstables 做合并.&lt;br&gt;对 level = 0 的 sstables, 在选择一个 sstable 后, 还需要找出所有与这个 sstable 有 key 范围重叠的 sstables, 最后统统与level 1 的 sstables 做合并.&lt;br&gt;不知之前是否注意到, level 0 的 sstables 可能有键范围的重合. (因为 level 0 的 sstable 是直接由 memtable 变过来的, 而不同的 memtable 之间并没有约束 key 必须独立.)&lt;/p&gt;
&lt;h4 id=&quot;merge-策略&quot;&gt;&lt;a href=&quot;#merge-策略&quot; class=&quot;headerlink&quot; title=&quot;merge 策略&quot;&gt;&lt;/a&gt;merge 策略&lt;/h4&gt;&lt;p&gt;compaction 过程中有提到选择 sstable, 如何选择? 这就看 leveldb 的 merge 策略了:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;level i 按顺序选择.&lt;/li&gt;
&lt;li&gt;level i+1 选择所有与 level i 所选 sstable(s) 有 key 范围重叠的 sstables.&lt;/li&gt;
&lt;li&gt;将这些 sstables 做 K 路归并排序. 对于相同的 key, 只保留最新的(上层 sstable, 同层中新的 sstable).&lt;/li&gt;
&lt;li&gt;清除参与此次 merge 的所有 sstables, 保留新的 sstable.&lt;br&gt;有了前面提到的 compaction 第二个约束和 merge 策略, 间接解释了 level 0 和其他 level 不同的原因: 在level 0 的 compaction后, level 1 产生的 sstable是没有 key范围重叠的, 因此向高层 level 的 compaction 也不会有同一个 level 下 key 范围重叠的 sstable 产生.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;到这里, leveldb 如何实现的 lsm-tree 就比较明朗了: 内存结构中写数据, 每次写只考虑当前 memtable, 不涉及其他结构的更新, 内存数据顺序迁移到外存中, 形成一个日志结构, 这就是 leveldb 顺序写的思路.&lt;/p&gt;
&lt;h3 id=&quot;LevelDB的写入和读取效率&quot;&gt;&lt;a href=&quot;#LevelDB的写入和读取效率&quot; class=&quot;headerlink&quot; title=&quot;LevelDB的写入和读取效率&quot;&gt;&lt;/a&gt;LevelDB的写入和读取效率&lt;/h3&gt;&lt;h4 id=&quot;高效的写入效率&quot;&gt;&lt;a href=&quot;#高效的写入效率&quot; class=&quot;headerlink&quot; title=&quot;高效的写入效率&quot;&gt;&lt;/a&gt;高效的写入效率&lt;/h4&gt;&lt;p&gt;到此为止, leveldb 的写入策略就介绍完了, 这里做个总结:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存 + 跳表&lt;/li&gt;
&lt;li&gt;外存中追加, 使用顺序写&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;读取效率如何&quot;&gt;&lt;a href=&quot;#读取效率如何&quot; class=&quot;headerlink&quot; title=&quot;读取效率如何?&quot;&gt;&lt;/a&gt;读取效率如何?&lt;/h4&gt;&lt;p&gt;说完了写, 那么并不具备读优势的 leveldb 读取是怎样设计的呢?&lt;/p&gt;
&lt;p&gt;毕竟凡事很难达到两全, 顺序写的这种结构就注定了丧失读效率(需要多次遍历寻址).&lt;br&gt;然而 leveldb 仍然费尽心思在代码层面而非算法层面做了优化.&lt;/p&gt;
&lt;p&gt;查询过程中优化的顺序如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存 + skiplist&lt;/li&gt;
&lt;li&gt;sstables B-search (通过 manifest 文件)&lt;/li&gt;
&lt;li&gt;页缓存&lt;/li&gt;
&lt;li&gt;bloom filter(周期性 compaction 做辅助)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在查询 level 0 sstables 时, 因为不同 sstables 的 key 范围可能有重叠, 所以只能把但凡包含 key 的 sstables 找出来, 排序取最新的 (manifest 文件记录了当前所有sstable 的信息, 包括文件名, 所处 level, key 的范围等等). 因为 sstable 是有序的, 所以在 level &amp;gt; 0 寻找 sstable 这一过程可以应用二分搜索完成. 找到 sstable 后, 读出其 index block, 加载到内存作为 table cache, 再根据索引去查具体的 data block. 而 data block 也包含了一组 k-v, 为了提高定位 key 的效率, leveldb 又引入了布隆过滤器这一数据结构.&lt;/p&gt;
&lt;h3 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/abbshr/abbshr.github.io/issues/58&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;存储引擎技术架构与内幕&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.open-open.com/lib/view/open1424916275249.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Log Structured Merge Trees(LSM) 原理&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;最后&quot;&gt;&lt;a href=&quot;#最后&quot; class=&quot;headerlink&quot; title=&quot;最后&quot;&gt;&lt;/a&gt;最后&lt;/h3&gt;&lt;p&gt;本文对结合LevelDB存储引擎对于LSM Tree原理进行了总结，大部分内容出自于引用，有时间希望能对存储引擎有多更多的了解。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;一直觉得数据库内部的实现是个黑匣子，总感觉很神秘，借着前段时间「海量存储」这门课程课堂报告的机会，读了一些Paper，虽然没能全部仔细读完，但是从每篇Paper的Abstract里面还是能窥见当前领域的近来的一些学术动态，很多东西没能记住，但是，印象唯独深刻的是，几乎大部分paper都在讨论：如何使得存储系统的I/O性能更快更有效率，如何使得同样的物理存储能够存储更多的数据内容？&lt;br&gt;
    
    </summary>
    
      <category term="Storage" scheme="https://zouzls.github.io/categories/Storage/"/>
    
    
      <category term="存储引擎" scheme="https://zouzls.github.io/tags/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
      <category term="LSM" scheme="https://zouzls.github.io/tags/LSM/"/>
    
  </entry>
  
  <entry>
    <title>git常用命令总结</title>
    <link href="https://zouzls.github.io/2016/11/17/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <id>https://zouzls.github.io/2016/11/17/git常用命令总结/</id>
    <published>2016-11-17T03:29:27.000Z</published>
    <updated>2016-11-28T16:43:25.578Z</updated>
    
    <content type="html">&lt;p&gt;因为最近项目用到git较多，一些常用的命令经常忘记，好记性不如烂笔头，索性总结一下。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h3&gt;&lt;p&gt;目前的使用场景就是在gitlab或者github开了一个repository远程仓库，而且存在两个branch分支，分别是master和dev分支，其中master用作发布，dev用作开发，经常提交更新是在dev分支。&lt;br&gt;需要在多台机子上进行代码同步，虽然开发工具eclipse中集成了Git插件，但是很多时候插件并不够友好，还是需要用Git命令来搞定。&lt;/p&gt;
&lt;h3 id=&quot;Git命令总结&quot;&gt;&lt;a href=&quot;#Git命令总结&quot; class=&quot;headerlink&quot; title=&quot;Git命令总结&quot;&gt;&lt;/a&gt;Git命令总结&lt;/h3&gt;&lt;h4 id=&quot;Git配置&quot;&gt;&lt;a href=&quot;#Git配置&quot; class=&quot;headerlink&quot; title=&quot;Git配置&quot;&gt;&lt;/a&gt;Git配置&lt;/h4&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 显示当前的Git配置,包括远程仓库、分支追踪关系等等&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git config --list&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 设置提交代码时的用户信息，注意：加--global，表示全局，否则为当前项目&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git config [--global] user.name &lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git config [--global] user.email &lt;span class=&quot;string&quot;&gt;&quot;email address&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;增加文件&quot;&gt;&lt;a href=&quot;#增加文件&quot; class=&quot;headerlink&quot; title=&quot;增加文件&quot;&gt;&lt;/a&gt;增加文件&lt;/h4&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 添加当前目录的所有文件到暂存区（☆）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git add .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 添加指定文件到暂存区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git add [file1] [file2] ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 添加指定目录到暂存区，包括子目录&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git add [dir]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;提交文件&quot;&gt;&lt;a href=&quot;#提交文件&quot; class=&quot;headerlink&quot; title=&quot;提交文件&quot;&gt;&lt;/a&gt;提交文件&lt;/h4&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 提交暂存区到仓库区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git commit -m [message]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 使用一次新的commit，替代上一次提交&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 如果代码没有任何新变化，则用来改写上一次commit的提交信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git commit --amend -m [message]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 还有可以修改上次提交author和committor信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;增加远程仓库&quot;&gt;&lt;a href=&quot;#增加远程仓库&quot; class=&quot;headerlink&quot; title=&quot;增加远程仓库&quot;&gt;&lt;/a&gt;增加远程仓库&lt;/h4&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 显示所有远程仓库&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git remote -v&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 增加一个新的远程仓库，并命名，比如：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# git remote add origin ssh://xxx.xx.xx/xx.git&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git remote add [shortname] [url]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果没有添加远程仓库，eclipse中每次push都需要手动添加远程仓库url，会很繁琐。&lt;/p&gt;
&lt;h4 id=&quot;追踪关系&quot;&gt;&lt;a href=&quot;#追踪关系&quot; class=&quot;headerlink&quot; title=&quot;追踪关系&quot;&gt;&lt;/a&gt;追踪关系&lt;/h4&gt;&lt;p&gt;在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分支，否则远程同步需要手动指定分支，而且体现在eclipse中就是另外一台机子eclipse拉取不到更新。&lt;br&gt;Git也允许手动建立追踪关系。&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 下面命令指定本地master分支追踪origin/dev分支。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git branch --set-upstream master origin/dev&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 下面的命令可以看到当前分支追踪的远程分支&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git branch -vv&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;指定追踪关系之后，我重新再eclipse中pull就能更新代码了。&lt;/p&gt;
&lt;h4 id=&quot;远程同步&quot;&gt;&lt;a href=&quot;#远程同步&quot; class=&quot;headerlink&quot; title=&quot;远程同步&quot;&gt;&lt;/a&gt;远程同步&lt;/h4&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# =========================git push==============================&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 注意，分支推送顺序的写法是&amp;lt;来源地&amp;gt;:&amp;lt;目的地&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 所以git pull是&amp;lt;远程分支&amp;gt;:&amp;lt;本地分支&amp;gt;，而git push是&amp;lt;本地分支&amp;gt;:&amp;lt;远程分支&amp;gt;。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git push &amp;lt;远程主机名&amp;gt; &amp;lt;本地分支名&amp;gt;:&amp;lt;远程分支名&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 如果省略远程分支名，则表示将本地分支推送与之存在&quot;追踪关系&quot;的远程分支（通常两者同名）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 如果该远程分支不存在，则会被新建。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git push origin master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 上面命令表示，将本地的master分支推送到origin主机的master分支。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 如果后者不存在，则会被新建。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git push origin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 上面命令表示，将当前分支推送到origin主机的对应分支。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 如果当前分支只有一个追踪分支，那么主机名都可以省略。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git push&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# =========================git pull==============================&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# git pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git pull &amp;lt;远程主机名&amp;gt; &amp;lt;远程分支名&amp;gt;:&amp;lt;本地分支名&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git pull origin dev&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git pull origin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 上面命令表示，本地的当前分支自动与对应的origin主机&quot;追踪分支&quot;（remote-tracking branch）进行合并。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 如果当前分支只有一个追踪分支，连远程主机名都可以省略。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git pull&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 上面命令表示，当前分支自动与唯一一个追踪分支进行合并。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;++++++++++++++++++++以下更新于2016.11.29日晚+++++++++++++++++++++&lt;/p&gt;
&lt;h4 id=&quot;7-分支管理&quot;&gt;&lt;a href=&quot;#7-分支管理&quot; class=&quot;headerlink&quot; title=&quot;7.分支管理&quot;&gt;&lt;/a&gt;7.分支管理&lt;/h4&gt;&lt;p&gt;一般最常见的就是一个master分支和一个dev分支，dev分支用于日常开发，master分支用于版本更新版本发布。&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 创建新的分支，比如在master分支外面在开一个dev分支&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git branch dev&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 切换到新的分支dev&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout dev&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 如果将上面两条命令合并在一起，就是创建新分支(dev)的同时，切换到新分支(dev)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout -b dev&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 切换到上一个分支的快捷方式，比如master&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout -&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 比如在dev上开发了一段时间，要将代码合并到master分支&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 可以先切换到master分支，然后执行下面命令&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git merge dev --no-ff&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 其中--no-ff的意思是，不将dev所有的提交节点合并到master分支上&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 这样做的好处是能保证master分支节点干净&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;8-标签管理&quot;&gt;&lt;a href=&quot;#8-标签管理&quot; class=&quot;headerlink&quot; title=&quot;8.标签管理&quot;&gt;&lt;/a&gt;8.标签管理&lt;/h4&gt;&lt;p&gt;标签其中一个用处是用来标记一些版本信息，比如在master分支上打上v1.0、v1.1等版本信息，这样版本更新信息一目了然。&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 在当前commit上添加标签tag&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git tag v1.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 可以指定给之前的commit添加tag，commit_id用commit号前几位就行（4位好像可以）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git tag v0.9 commit_id&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;常用 Git 命令清单&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/06/git_remote.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Git远程操作详解&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;最后&quot;&gt;&lt;a href=&quot;#最后&quot; class=&quot;headerlink&quot; title=&quot;最后&quot;&gt;&lt;/a&gt;最后&lt;/h3&gt;&lt;p&gt;本文会随Git的使用时常更新。&lt;/p&gt;
&lt;p&gt;-EOF-&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;因为最近项目用到git较多，一些常用的命令经常忘记，好记性不如烂笔头，索性总结一下。&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="https://zouzls.github.io/categories/Git/"/>
    
    
      <category term="git" scheme="https://zouzls.github.io/tags/git/"/>
    
      <category term="常用命令" scheme="https://zouzls.github.io/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM之Java内存模型（三）</title>
    <link href="https://zouzls.github.io/2016/10/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E4%B9%8BJMM%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://zouzls.github.io/2016/10/17/深入理解JVM之JMM（三）/</id>
    <published>2016-10-17T07:59:37.000Z</published>
    <updated>2016-10-17T16:08:53.150Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;Java内存模型的主要目标是定义程序中的各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。&lt;/strong&gt;此处的变量跟java编程中的变量有一定的区别，它包括实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然不存在竞争问题。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;主内存和工作内存&quot;&gt;&lt;a href=&quot;#主内存和工作内存&quot; class=&quot;headerlink&quot; title=&quot;主内存和工作内存&quot;&gt;&lt;/a&gt;主内存和工作内存&lt;/h3&gt;&lt;p&gt;这里说的主内存和java内存区域中的java堆、栈、方法区并不是一个同一个层次的内存划分，基本没有关系。如果非要对应起来，主内存应该对应于java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20130523001112026&quot; alt=&quot;&quot;&gt;&lt;br&gt;上图是Java虚拟机运行时数据区，可以看到虚拟机栈是线程隔离的区域，即线程私有，java堆是所有线程共享的。&lt;br&gt;再次回到主内存和工作内存，Java内存模型规定了所有变量都存储在主内存中，每条线程有自己的工作内存，线程的工作内存保存了被该线程用到的变量的主内存副本拷贝，线程对变量所有的操作都必须在工作内存中进行，而不能直接读写主内存中的变量，不同的线程间变量值的传递均需要通过主内存来完成。线程、主内存、工作内存三者关系如下图：&lt;br&gt;&lt;img src=&quot;http://7xisp0.com1.z0.glb.clouddn.com/jvm_mem_model_relationship.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;内存间交互操作&quot;&gt;&lt;a href=&quot;#内存间交互操作&quot; class=&quot;headerlink&quot; title=&quot;内存间交互操作&quot;&gt;&lt;/a&gt;内存间交互操作&lt;/h3&gt;&lt;p&gt;关于主内存和工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步会主内存之类的细节。JMM定义了8种操作来完成，虚拟机实现时必须保证每一种操作都是原子的不可再分的。&lt;br&gt;如果把一个变量从主内存复制到工作内存，就要顺序执行read和load操作，如果要把变量从工作内存同步回主内存，就要顺序执行store和write操作。注意，java内存模型只要求上述两个操作必须按顺序执行，而且没有保证是连续执行。除此之外，java内存模型还规定了在执行8种操作必须满足的规则，但是这种规则繁琐麻烦，后面等效判断的「先行发生原则」可以同样来确定一个访问在并发环境下是否安全。&lt;/p&gt;
&lt;h3 id=&quot;对于volatile型变量的特殊规则&quot;&gt;&lt;a href=&quot;#对于volatile型变量的特殊规则&quot; class=&quot;headerlink&quot; title=&quot;对于volatile型变量的特殊规则&quot;&gt;&lt;/a&gt;对于volatile型变量的特殊规则&lt;/h3&gt;&lt;p&gt;关键字volatile可以说是java虚拟机提供的最轻量级的同步机制。当一个变量定义为volatile之后，它将具备两种特性：&lt;/p&gt;
&lt;h4 id=&quot;保证变量对所有线程的可见性&quot;&gt;&lt;a href=&quot;#保证变量对所有线程的可见性&quot; class=&quot;headerlink&quot; title=&quot;保证变量对所有线程的可见性&quot;&gt;&lt;/a&gt;保证变量对所有线程的可见性&lt;/h4&gt;&lt;p&gt;这里的可见性是指当一条线程修改了这个变量的值，新值对其他线程来说是可以立即得知的。&lt;strong&gt;Volatile 变量具有 synchronized 的可见性特性，但是不具备原子特性。&lt;/strong&gt;这就是说线程能够自动发现 volatile 变量的最新值。Volatile 变量可用于提供线程安全，但是只能应用于非常有限的一组用例：多个变量之间或者某个变量的当前值与修改后值之间没有约束。因此，单独使用 volatile 还不足以实现计数器、互斥锁或任何具有与多个变量相关的不变式（Invariants）的类（例如 “start &amp;lt;=end”）。您只能在有限的一些情形下使用 volatile 变量替代锁。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对变量的写操作不依赖于当前值。&lt;/li&gt;
&lt;li&gt;该变量没有包含在具有其他变量的不变式中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。第一个条件的限制使 volatile 变量不能用作线程安全计数器。虽然增量操作（x++）看上去类似一个单独操作，实际上它是一个由读取－修改－写入操作序列组成的组合操作，必须以原子方式执行，而 volatile 不能提供必须的原子特性。实现正确的操作需要使 x 的值在操作期间保持不变，而 volatile 变量无法实现这点。（然而，如果将值调整为只从单个线程写入，那么可以忽略第一个条件。）&lt;br&gt;&lt;strong&gt;要始终牢记使用 volatile 的限制 —— 只有在状态真正独立于程序内其他内容时才能使用 volatile —— 这条规则能够避免将这些模式扩展到不安全的用例。&lt;/strong&gt;其中一种典型的模式应用就是将 volatile 变量作为状态标志使用，很多应用程序包含了一种控制结构，形式为 “在还没有准备好停止程序时再执行一些工作”，如下列代码所示：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; shutdownRequested;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;shutdown&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123; shutdownRequested = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;doWork&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (!shutdownRequested) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// do stuff&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;很可能会从循环外部调用 shutdown() 方法 —— 即在另一个线程中 —— 因此，需要执行某种同步来确保正确实现 shutdownRequested 变量的可见性。由于 volatile简化了编码，并且状态标志并不依赖于程序内任何其他状态，因此此处非常适合使用 volatile。&lt;/p&gt;
&lt;h4 id=&quot;禁止指令重排&quot;&gt;&lt;a href=&quot;#禁止指令重排&quot; class=&quot;headerlink&quot; title=&quot;禁止指令重排&quot;&gt;&lt;/a&gt;禁止指令重排&lt;/h4&gt;&lt;p&gt;使用volatile的第二个语义是禁止指令重排，普通的变量仅仅会保证在该方法执行过程中所有依赖赋值结果的地方都能取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在一个线程的方法执行过程中无法感知到这点，这就是JMM中所谓的“线程内表现为串行的语义”，举例代码如下：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//全局变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; open=&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//线程A&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;resource.close();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;open = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//线程B&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(open) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    doSomethingWithResource(resource);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果定义open变量没有使用volatile修饰，就可能由于指令重排的优化，导致线程A最后一句的代码被提前执行。&lt;/p&gt;
&lt;p&gt;解决了volatile的语义问题，再来看看在众多保障并发安全的工具中选用volatile的意图——它能让我们的代码更快吗？在某些情况下，volatile的同步机制的性能确实要优于锁，但是优于虚拟机对锁实行的许多优化和消除，使我们很难认为volatile就会比synchronized快多少。但是我们可以确定volatile的读操作性能与普通变量没啥区别，写操作要慢些，因为它要在本地代码中插入许多内存屏障来保证处理器不发生乱序执行。我们在volatile和锁之间选择的唯一依据仅仅是volatile的语义能否适用场景的需求。&lt;/p&gt;
&lt;h3 id=&quot;先行发生原则「Happends-Before」&quot;&gt;&lt;a href=&quot;#先行发生原则「Happends-Before」&quot; class=&quot;headerlink&quot; title=&quot;先行发生原则「Happends-Before」&quot;&gt;&lt;/a&gt;先行发生原则「Happends-Before」&lt;/h3&gt;&lt;p&gt;这个原则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据。先行发生是JMM中定义两项操作的偏序关系，如果操作A先行发生于操作B，则说明操作A产生的影响一定能被B观察到。下面是JMM中天然的先行发生关系，这些先行发生关系无需任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则中推导出来，它们就没有顺序保障，虚拟机可以对它们随意进行重排序。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序次序规则：在一个线程内，按照代码顺序（准确的说是控制流顺序），书写在前面的操作先于后面的操作。&lt;/li&gt;
&lt;li&gt;管程锁定规则&lt;/li&gt;
&lt;li&gt;volatile变量：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的后面就是“时间”的先后顺序。&lt;/li&gt;
&lt;li&gt;线程启动规则&lt;/li&gt;
&lt;li&gt;线程终止规则&lt;/li&gt;
&lt;li&gt;线程中断规则&lt;/li&gt;
&lt;li&gt;对象终结规则&lt;/li&gt;
&lt;li&gt;传递性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举例代码如下：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; value=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setValue&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; value)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.value=value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getValue&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中，线程A先调用了一个对象的setValue(1)，然后线程B调用了同一个对象的getValue()，那么线程B收到的返回值是什么？&lt;br&gt;如果对照上述的先行发生规则，该案例操作不符合任意条规则，所以这里面的操作不是安全的。&lt;br&gt;那么怎么修复这个问题？有两个方案可以选择，要么是对getter、setter方法定义为synchronized方法，这样就可以套用官程锁定规则；要么把value定义为volatile变量，由于setter对value的修改不依赖value的原值，满足volatile的场景，这样也可以套用volatile变量规则来实现先行发生关系。通过上面的例子，可以得出：一个操作“时间上的先发生”不代表这个操作会是“先行发生”。&lt;br&gt;那如果一个操作是满足先行发生关系，是不是就能推导出这个操作必定是时间上先发生呢？示例代码如下：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//同一线程中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;结论是不成立的，因为由于指令重排，int j=2完全有可能先被执行，但是并不影响先行发生的准确性。上面两个例子证明了：时间先后顺序和先行发生原则关系并不太大，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生规则为准。&lt;/p&gt;
&lt;p&gt;-EOF-&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Java内存模型的主要目标是定义程序中的各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。&lt;/strong&gt;此处的变量跟java编程中的变量有一定的区别，它包括实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然不存在竞争问题。&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://zouzls.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://zouzls.github.io/tags/JVM/"/>
    
      <category term="JMM" scheme="https://zouzls.github.io/tags/JMM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM之JIT编译器（二）</title>
    <link href="https://zouzls.github.io/2016/09/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E4%B9%8BJIT%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://zouzls.github.io/2016/09/07/深入理解JVM之JIT编译器（二）/</id>
    <published>2016-09-07T06:40:16.000Z</published>
    <updated>2016-09-07T16:14:53.794Z</updated>
    
    <content type="html">&lt;p&gt;上篇是分析了一下前段编译器，主要过程完成从java代码到字节码的转变，它的改进顶多是提高程序的编码速度和效率。本篇尝试探索JIT编译器，它能够完成从字节码到本地机器码的转变，从而真正的影响程序的运行效率。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;部分商用虚拟机，程序最初是通过解释器（Interpreter）进行解释执行，当发现某个部分代码频繁执行的时候，就会将这些代码认定为「热点代码」（即 Hot Spot Code）。&lt;strong&gt;为了提高热点代码的执行效率，在运行时，虚拟机会把这些代码编译成与本地平台相关的机器码，并进行各种优化，完成这个任务的编译器成为即时编译器（Just In Time Compiler，简称JIT编译器）。&lt;/strong&gt;（下文所指均为JIT）关于即时编译器需要知道的几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它并不是VM必需的部分，java虚拟机规范并没有规定它必须存在，所以也没限定如何去实现。&lt;/li&gt;
&lt;li&gt;即时编译器编译性能的好坏、代码优化程度高低是衡量商用虚拟机优秀与否最关键指标之一。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Hotspot-VM的JIT编译器&quot;&gt;&lt;a href=&quot;#Hotspot-VM的JIT编译器&quot; class=&quot;headerlink&quot; title=&quot;Hotspot VM的JIT编译器&quot;&gt;&lt;/a&gt;Hotspot VM的JIT编译器&lt;/h3&gt;&lt;h4 id=&quot;解释器和编译器&quot;&gt;&lt;a href=&quot;#解释器和编译器&quot; class=&quot;headerlink&quot; title=&quot;解释器和编译器&quot;&gt;&lt;/a&gt;解释器和编译器&lt;/h4&gt;&lt;p&gt;不是所有Java虚拟机均采用二者并存的架构，但是一些主流商用虚拟机如Hotspot、J9都会同时包含二者。关于二者的优势如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;程序刚启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行字节码。&lt;/li&gt;
&lt;li&gt;程序运行之后，经过一段时间，编译器可以逐渐发挥作用，把更多的代码编译为本地机器码，获得更高的执行效率。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在整个虚拟机执行架构中，解释器和编译器经常配合工作，如下图所示：&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151105003122855&quot; alt=&quot;&quot;&gt;&lt;br&gt;上图中内置了两个JIT编译器，分别称Client Compiler和Server Compiler，简称为C1编译器和C2编译器。目前主流的Hotspot VM（jdk1.7及以前版本虚拟机），默认采用与其中一个编译器直接配合，程序用哪个，取决于虚拟机运行模式，用户可以使用-client和-server参数强制指定虚拟机运行在client和server模式。&lt;br&gt;另外，通过下图的三种命令可以强制虚拟机运行的模式，分别为：Mixed Mode（混合模式，默认情况下解释器和编译器搭配使用）、Interpreter Mode（解释模式）、Compiled Mode（编译模式）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oaewlsdmg.bkt.clouddn.com/image/jpg/QQ%E6%88%AA%E5%9B%BE20160907155152.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;了解完解释器和编译器之后，我们想知道那些代码会被编译？在什么情况下会触发编译？基于这两个问题，来了解编译对象和触发条件。&lt;/p&gt;
&lt;h4 id=&quot;编译对象&quot;&gt;&lt;a href=&quot;#编译对象&quot; class=&quot;headerlink&quot; title=&quot;编译对象&quot;&gt;&lt;/a&gt;编译对象&lt;/h4&gt;&lt;p&gt;在运行过程中会被即时编译器编译的「热点代码」有两类，如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;被多次调用的方法&lt;/li&gt;
&lt;li&gt;被多次执行的循环体&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于这两种情况，有两点解释：对于第一种情况，是由方法调用触发的编译，理所当然的会以整个方法体作为编译对象，这种编译是虚拟机中标准的JIT编译。对于第二种情况，编译动作由循环体触发，但是编译器仍旧会以整个方法作为编译对象，由于这种方法发生在方法执行过程中，所以称为栈上替换（On Stack Replacement，简称OSR编译，因为方法栈帧还在栈上）。&lt;/p&gt;
&lt;h4 id=&quot;触发条件&quot;&gt;&lt;a href=&quot;#触发条件&quot; class=&quot;headerlink&quot; title=&quot;触发条件&quot;&gt;&lt;/a&gt;触发条件&lt;/h4&gt;&lt;p&gt;正如上面所说的“多次”并不够严谨和具体，那么如何才算是“多次”呢？以及怎么样去统计一个方法和一段代码被执行多少次呢？回答了这两个问题就是回答了触发条件。&lt;strong&gt;判断一段代码是不是热点代码，是不是需要触发即时编译，这样的行为叫「热点探测」&lt;/strong&gt;。关于热点探测有两种方式，如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于采样的热点探测&lt;br&gt;虚拟机会周期性检查各个线程的栈顶，如果发现某些方法长期占据栈顶，那么会被认为是「热点代码」。简单、高效，但是不够精确，因为某些方法会因为线程阻塞或其他原因扰乱热点探测。&lt;/li&gt;
&lt;li&gt;基于计数器的热点探测（Hotspot VM采用）&lt;br&gt;虚拟机为每个方法或者代码块建立计数器，统计执行次数，超过一定阀值会被认为是「热点代码」。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Hotspot VM使用第二种，并且为每个方法准备了两种计数器：方法调用计数器和回边计数器（在字节码中遇到控制流向后跳转的指令称为“回边 ”）。在确定虚拟运行参数的情况下，这两个计数器都有一个确定的阀值，超过这个阀值就会触发JIT编译。方法调用计数器触发即时编译的交互过程如下图：&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151106000550960&quot; alt=&quot;&quot;&gt;&lt;br&gt;注意：方法调用计数器统计的并不是被调用的绝对次数，而是一个相对的执行频率，即一段时间被被调用的次数。&lt;/p&gt;
&lt;h4 id=&quot;编译过程&quot;&gt;&lt;a href=&quot;#编译过程&quot; class=&quot;headerlink&quot; title=&quot;编译过程&quot;&gt;&lt;/a&gt;编译过程&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;在默认设置下，无论是方法调用产生的即时编译请求，还是OSR编译请求，虚拟机在代码编译还未完成之前，都仍然按照解释方式执行，而编译动作则在后台编译线程中进行。&lt;/strong&gt;至于在后台如何执行编译过程，Client Compiler和Server Compiler的编译过程是不同的。二者大致区别如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Client Compiler：主要关注点在局部优化，而放弃了耗时较长的全局优化手段。&lt;/li&gt;
&lt;li&gt;Server Compiler：是专门面向服务器端的典型应用并为服务端的性能配置特别调整过。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从即时编译的角度看，Server Compiler是比较慢，但其编译速度又远远超过「静态优化编译器」，而且比Client Compiler输出的代码质量高，可以减少本地代码执行时间，从而抵消额外的编译时间。&lt;/p&gt;
&lt;h3 id=&quot;编译优化技术&quot;&gt;&lt;a href=&quot;#编译优化技术&quot; class=&quot;headerlink&quot; title=&quot;编译优化技术&quot;&gt;&lt;/a&gt;编译优化技术&lt;/h3&gt;&lt;p&gt;之所以有编译方式执行本地代码比解释方式更快这样的共识，原因很简单，是因为虚拟机设计团队几乎把对代码所有的优化措施集中在了即时编译器之中，因此一般来说，即时编译器产生的本地代码会比Javac产生的字节码更优秀。常用优化技术如下：&lt;/p&gt;
&lt;h4 id=&quot;公共子表达式消除&quot;&gt;&lt;a href=&quot;#公共子表达式消除&quot; class=&quot;headerlink&quot; title=&quot;公共子表达式消除&quot;&gt;&lt;/a&gt;公共子表达式消除&lt;/h4&gt;&lt;p&gt;语言无关，比如像：b乘c、c乘b这样的表达式值都是一样的可以直接替换。&lt;/p&gt;
&lt;h4 id=&quot;数组范围消除&quot;&gt;&lt;a href=&quot;#数组范围消除&quot; class=&quot;headerlink&quot; title=&quot;数组范围消除&quot;&gt;&lt;/a&gt;数组范围消除&lt;/h4&gt;&lt;p&gt;语言相关，&lt;strong&gt;主要思路就是尽可能把运行期检查提任务前到编译器进行&lt;/strong&gt;，以至于在循环遍历的时候不需要每次都要判断变量大小是否超过数组范围，带来隐式开销，只要在编译期根据数据流获得数组的length，并且判断下标没有越界，执行的时候就无需判断了。&lt;/p&gt;
&lt;h4 id=&quot;方法内联&quot;&gt;&lt;a href=&quot;#方法内联&quot; class=&quot;headerlink&quot; title=&quot;方法内联&quot;&gt;&lt;/a&gt;方法内联&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;为了消除方法调用的成本，&lt;/strong&gt;同时为其他优化手段建立好的基础。因为很多方法分开看是有意义的，如果不做方法内联，即使进行了无用代码消除，也无法发现任何“Dead Code”。&lt;/p&gt;
&lt;h4 id=&quot;逃逸分析&quot;&gt;&lt;a href=&quot;#逃逸分析&quot; class=&quot;headerlink&quot; title=&quot;逃逸分析&quot;&gt;&lt;/a&gt;逃逸分析&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;并不是直接的优化手段，而是为其他优化手段提供分析技术。&lt;/strong&gt;逃逸分析的基本行为就是分析对象的作用域，比如一个对象在一个方法中被定义，可能被外部方法所引用，例如作为方法参数传递到其他方法中，这被称为方法逃逸。甚至可能被其他线程访问，例如赋值给类变量或其他线程访问的实例变量，就是线程逃逸。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因此，如果能证明一个不会发生方法或者线程逃逸，则可以为这个变量进行一些高效优化。优化措施如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;栈上分配&lt;br&gt;将确定不会逃逸的对象在在栈帧上进行创建分配内存，这样方法结束时，对象就会随着栈帧出栈而销毁，减少堆内存垃圾回收的压力。&lt;/li&gt;
&lt;li&gt;同步消除&lt;br&gt;如果确定一个变量不会线程逃逸，也就说明该变量不会发生线程竞争，从而消除掉该变量的同步措施。&lt;/li&gt;
&lt;li&gt;标量替换&lt;br&gt;像java中的原始数据类型如int、long均称为标量（表示无法分解为更小的数据来表示了），如果一个数据可以继续分解，则为聚合量，而java中的对象则为典型的聚合量。如果一个对象不会被外部访问，而这个对象可以被拆散分解，那么就不去创建这个对象，而是直接创建被使用到的成员变量。而这些成员变量除了被分配在栈上（栈上的数据很容易会被虚拟机分配到物理高速寄存器）进行读和写，还为后续优化创造基础条件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本篇主要了解解释器和编译器的特点和各自优势、然后总结了编译对象和编译条件，最后介绍了编译过程以及用到的一些主要的编译优化技术，算是对即时编译器有个基本的理解了。&lt;/p&gt;
&lt;p&gt;-EOF-&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;上篇是分析了一下前段编译器，主要过程完成从java代码到字节码的转变，它的改进顶多是提高程序的编码速度和效率。本篇尝试探索JIT编译器，它能够完成从字节码到本地机器码的转变，从而真正的影响程序的运行效率。&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://zouzls.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://zouzls.github.io/tags/JVM/"/>
    
      <category term="JIT" scheme="https://zouzls.github.io/tags/JIT/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM之前端编译器（一）</title>
    <link href="https://zouzls.github.io/2016/09/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E4%B9%8B%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://zouzls.github.io/2016/09/06/深入理解JVM之前端编译器（一）/</id>
    <published>2016-09-06T15:50:44.000Z</published>
    <updated>2016-09-07T16:17:49.234Z</updated>
    
    <content type="html">&lt;p&gt;前两天在leetcode做了算法题，惊讶的发现用java实现的时间复杂度，竟然跻身于C/C++同列，甚至偶尔会超过后两者，虽然知道JVM功不可没，但还是很好奇在VM编译过程中到底发生了什么，翻出《深入理解java虚拟机》一探究竟，算是有所收获，记录如下。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;java语言的“编译期”其实是一段“不确定”的操作过程，因为可能是下面三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前端编译器&lt;br&gt;叫编译器的前端可能更合适，&lt;strong&gt;主要是把&lt;em&gt;.java文件转变成&lt;/em&gt;.class文件。&lt;/strong&gt;主要种类有：Sun的Javac、Eclipse JDT的增量式编译器（ECJ）。&lt;/li&gt;
&lt;li&gt;JIT编译器&lt;br&gt;就是可能指虚拟机的后端运行期编译器（JIT编译器：Just In Time Compiler），&lt;strong&gt;把「字节码」变成「机器码」&lt;/strong&gt;，主要有：Hotspot VM的C1、C2编译器。&lt;/li&gt;
&lt;li&gt;AOT编译器&lt;br&gt;上面两个可能关心更多，这个是指用静态提前编译器（AOT编译器：Ahead Of Time Compiler）直接把*.java变成本地机器码的过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文后面所指的编译器和编译期都表示第一种。&lt;br&gt;关于优化的两点解释：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Javac这类编译器对代码的运行效率几乎没有任何优化措施。只是做了一些针对java语言「编码过程」的“优化”措施来改善程序员的「编码风格和编码效率」（俗称“语法糖”，并没有涉及虚拟机底层的改进）。&lt;/li&gt;
&lt;li&gt;虚拟机设计团队把对性能的优化集中到了后端的即时编译中，这样可以让那些不是有javac产生的Class文件（如JRuby、Groovy等语言的Class）也同样能享受到编译器优化所带来的好处。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也就是说java中即时编译器的在运行期的优化对程序运行更重要，而前端编译器在编译期的优化对于程序编码更重要。注意此处的「编译期」和「运行期」、「程序编码」和「程序运行」的区别。&lt;/p&gt;
&lt;h3 id=&quot;Javac编译器&quot;&gt;&lt;a href=&quot;#Javac编译器&quot; class=&quot;headerlink&quot; title=&quot;Javac编译器&quot;&gt;&lt;/a&gt;Javac编译器&lt;/h3&gt;&lt;p&gt;Javac不像是Hotspot虚拟机本身是CPP（少量C）写的，本身是java语言编写的程序，这样java程序员就很方便了解它的编译过程了。关于源码环境搭建和调试不做详述，大致说下Javac的编译过程，主要分为3个过程，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解析与填充符号表过程&lt;/li&gt;
&lt;li&gt;插入式注解处理器的注解处理过程&lt;/li&gt;
&lt;li&gt;分析与字节码生成过程&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Java语法糖&quot;&gt;&lt;a href=&quot;#Java语法糖&quot; class=&quot;headerlink&quot; title=&quot;Java语法糖&quot;&gt;&lt;/a&gt;Java语法糖&lt;/h3&gt;&lt;p&gt;语法糖虽不能带来实质性的功能的改进，但是它们或能提高效率，或能提升语法严谨性，或能减少编码出错机会。java中常见的语法糖如下：&lt;/p&gt;
&lt;h4 id=&quot;泛型与泛型擦除&quot;&gt;&lt;a href=&quot;#泛型与泛型擦除&quot; class=&quot;headerlink&quot; title=&quot;泛型与泛型擦除&quot;&gt;&lt;/a&gt;泛型与泛型擦除&lt;/h4&gt;&lt;p&gt;java的泛型规则只在程序源码中存在，在编译后就已经替换为原来的原生类型（RawType，裸类型），并且在相应的地方插入了强制转换。&lt;/p&gt;
&lt;h4 id=&quot;自动装箱、拆箱与遍历循环、变长参数&quot;&gt;&lt;a href=&quot;#自动装箱、拆箱与遍历循环、变长参数&quot; class=&quot;headerlink&quot; title=&quot;自动装箱、拆箱与遍历循环、变长参数&quot;&gt;&lt;/a&gt;自动装箱、拆箱与遍历循环、变长参数&lt;/h4&gt;&lt;p&gt;演示代码如下（以下jdk环境1.8）：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AutoBoxCompile&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List&amp;lt;Integer&amp;gt; list =Arrays.asList(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; sum=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (Integer i : list) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            sum+=i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(sum);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;用的本地jd-gui.exe工具反编译之后变成：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AutoBoxCompile&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    List list = Arrays.asList(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Integer[] &amp;#123; Integer.valueOf(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), Integer.valueOf(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;), Integer.valueOf(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;), Integer.valueOf(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;) &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; sum = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (Integer i : list) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      sum += i.intValue();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(sum);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;foreach明明是一颗语法糖特性，猜想是工具的问题，找了一个&lt;a href=&quot;http://www.ludaima.cn/java.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在线反编译工具&lt;/a&gt;，得到下列代码，可以发现变长参数、自动装箱和遍历循环的语法糖特性：&lt;br&gt;&lt;img src=&quot;http://oaewlsdmg.bkt.clouddn.com/image/jpg/QQ%E5%9B%BE%E7%89%8720160907102754.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;条件编译&quot;&gt;&lt;a href=&quot;#条件编译&quot; class=&quot;headerlink&quot; title=&quot;条件编译&quot;&gt;&lt;/a&gt;条件编译&lt;/h4&gt;&lt;p&gt;类似于下面这段if代码，在编译过程中就会被“运行”。&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Ifcompiler&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&lt;span class=&quot;number&quot;&gt;1111&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&lt;span class=&quot;number&quot;&gt;2222&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;生成的字节码只包括System.out.println(1111);，将上述编译之后产生的class反编译如下图：&lt;br&gt;&lt;img src=&quot;http://oaewlsdmg.bkt.clouddn.com/image/jpg/QQ%E6%88%AA%E5%9B%BE20160907095715.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;只有使用条件为常量的if语句才能有上述效果，否则会被拒绝编译比如while(false){};。&lt;br&gt;还有很多其他的语法糖，比如内部类、枚举、断言、switch以及try中关闭资源等等，有时间再去尝试，重要的是明白语法糖是怎么回事。&lt;/p&gt;
&lt;h3 id=&quot;最后&quot;&gt;&lt;a href=&quot;#最后&quot; class=&quot;headerlink&quot; title=&quot;最后&quot;&gt;&lt;/a&gt;最后&lt;/h3&gt;&lt;p&gt;「之所以把从java文件到字节码文件的编译器叫做前段编译器，是因为它只完成了从程序到抽象语法树或者中间字节码的转变，而在此之后还有一组内置于虚拟机内部的“后端编译器”完成了从字节码到本地机器码的过程，即前面提到的即时编译器或JIT编译器，这个编译器的编译速度及结果的优劣，是衡量虚拟机性能的很重要的指标。」&lt;br&gt;JVM还有很多的东西没有去挖掘，希望这是个开端，能不断的去探索java虚拟机更深处的东西。&lt;/p&gt;
&lt;p&gt;-EOF-&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;前两天在leetcode做了算法题，惊讶的发现用java实现的时间复杂度，竟然跻身于C/C++同列，甚至偶尔会超过后两者，虽然知道JVM功不可没，但还是很好奇在VM编译过程中到底发生了什么，翻出《深入理解java虚拟机》一探究竟，算是有所收获，记录如下。&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://zouzls.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://zouzls.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Raft算法笔记之安全性（四）</title>
    <link href="https://zouzls.github.io/2016/08/28/Raft%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>https://zouzls.github.io/2016/08/28/Raft算法笔记之安全性（四）/</id>
    <published>2016-08-28T02:14:07.000Z</published>
    <updated>2016-08-28T04:04:37.031Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;前面的章节里描述了 Raft 算法是如何选举和复制日志的。然而，到目前为止描述的机制并不能充分的保证每一个状态机会按照相同的顺序执行相同的指令。&lt;/strong&gt;例如，一个跟随者可能会进入不可用状态同时领导人已经提交了若干的日志条目，然后这个跟随者可能会被选举为领导人并且覆盖这些日志条目；因此，不同的状态机可能会执行不同的指令序列。&lt;/p&gt;
&lt;p&gt;这一节通过在领导选举的时候增加一些限制来完善了 Raft 算法。&lt;strong&gt;这一限制保证了任何的领导人对于给定的任期号，都拥有了之前任期的所有被提交的日志条目。&lt;/strong&gt;增加这一选举时的限制，我们对于提交时的规则也更加清晰。最终，我们展示对于领导人完整特性的简要证明并且说明领导人是如何领导复制状态机的正确行为的。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;领导人选举的限制&quot;&gt;&lt;a href=&quot;#领导人选举的限制&quot; class=&quot;headerlink&quot; title=&quot;领导人选举的限制&quot;&gt;&lt;/a&gt;领导人选举的限制&lt;/h3&gt;&lt;p&gt;在任何基于领导人的一致性算法中，领导人都必须存储所有已经提交的日志条目。在某些一致性算法中，例如 Viewstamped Replication，一个人可以被选举为领导人即使他一开始并没有包含所有已经提交的日志条目。这种算法包含一些额外的机制来识别丢失的日志条目并把他们传送给新的领导人，要么是在选举阶段要么在之后很快进行。不幸的是，这种方法会导致相当大的额外的机制和复杂性。&lt;strong&gt;Raft 使用了一种更加简单的方法，它可以保证所有之前的任期号中已经提交的日志条目在选举的时候都会出现在新的领导人中，不需要传送这些日志条目给领导人。这意味着日志条目的传送是单向的，只从领导人传给跟随者，并且领导人从不会覆盖本地日志中已经存在的条目。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;候选人日志至少跟大多数一样新&quot;&gt;&lt;a href=&quot;#候选人日志至少跟大多数一样新&quot; class=&quot;headerlink&quot; title=&quot;候选人日志至少跟大多数一样新&quot;&gt;&lt;/a&gt;候选人日志至少跟大多数一样新&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;Raft 使用投票的方式来阻止候选人赢得选举除非这个候选人包含了所有已经提交的日志条目。(注意此处是所有已经提交的，注意理解&lt;/strong&gt;候选人为了赢得选举必须联系集群中的大部分节点，这意味着每一个已经提交的日志条目肯定在这些服务器节点中至少存在一个上面。&lt;strong&gt;如果候选人的日志至少和大多数的服务器节点一样新，那么他一定持有了所有已经提交的日志条目。（这是肯定的，因为只有只有候选人包含了所有已经提交的日志才能当领导人&lt;/strong&gt;请求投票 RPC 实现了这样的限制： RPC 中包含了候选人的日志信息，然后投票人会拒绝掉那些日志没有自己新的投票请求。&lt;/p&gt;
&lt;h4 id=&quot;新的比较：索引值和任期号&quot;&gt;&lt;a href=&quot;#新的比较：索引值和任期号&quot; class=&quot;headerlink&quot; title=&quot;新的比较：索引值和任期号&quot;&gt;&lt;/a&gt;新的比较：索引值和任期号&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;Raft 通过比较两份日志中最后一条日志条目的索引值和任期号定义谁的日志比较新。&lt;/strong&gt;如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新。如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新。&lt;/p&gt;
&lt;h3 id=&quot;提交之前任期内的日志条目&quot;&gt;&lt;a href=&quot;#提交之前任期内的日志条目&quot; class=&quot;headerlink&quot; title=&quot;提交之前任期内的日志条目&quot;&gt;&lt;/a&gt;提交之前任期内的日志条目&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;领导人知道知道一条当前任期内的日志记录是可以被提交的只要它被存储到了大多数的服务器上。&lt;/strong&gt;（注意措辞使用，可以被提交的而不是一定能成功提交的！）如果一个领导人在提交日志条目之前崩溃了，未来后续的领导人会继续尝试复制这条日志记录。&lt;strong&gt;然而，一个领导人不能断定一个之前任期里的日志条目被保存到大多数服务器上的时候就一定已经提交了。&lt;/strong&gt;（当日志确实被保存在了大部分服务器上，但是可能没有来得及提交！）图 8 展示了一种情况，一条已经被存储到大多数节点上的老日志条目，也依然有可能会被未来的领导人覆盖掉。&lt;br&gt;&lt;img src=&quot;http://oaewlsdmg.bkt.clouddn.com/image/jpg/Image.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图 8：如图的时间序列展示了为什么领导人无法通过老的日志的任期号来判断其提交状态。在 (a) 中，S1 是领导者，部分的复制了索引位置 2 的日志条目。在 (b) 中，S1 崩溃了，然后 S5 在任期 3 里通过 S3、S4 和自己的选票赢得选举，然后从客户端接收了一条不一样的日志条目放在了索引 2 处。然后到 (c)，S5 又崩溃了；S1 重新启动，选举成功，开始复制日志。在这时，来自任期 2 的那条日志已经被复制到了集群中的大多数机器上，但是还没有被提交。如果 S1 在 (d) 中又崩溃了，S5 可以重新被选举成功（通过来自 S2，S3 和 S4 的选票），然后覆盖了他们在索引 2 处的日志。但是，在崩溃之前，如果 S1 在自己的任期里复制了日志条目到大多数机器上，如 (e) 中，然后这个条目就会被提交（S5 就不可能选举成功）。 在这个时候，之前的所有日志就会被正常提交处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;为了像图 8 里描述的情况，Raft 通过计算副本数目的方式，使得永远不会提交一个之前任期内的日志条目。(永远不会提交！注意是提交！领导人当前任期之前的条目绝逼是已经被提交了，不能和日志复制搞混淆！)&lt;/strong&gt;通过计算副本数目，只有领导人当前任期里的日志条目可以被提交；一旦当前任期的日志条目以这种方式被提交，那么由于日志匹配特性，之前的日志条目也都会被间接的提交。在某些情况下，领导人可以安全的知道一个老的日志条目是否已经被提交（例如，该条目是否存储到所有服务器上），但是 Raft 为了简化问题使用一种更加保守的方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当领导人复制之前任期里的日志时，Raft 会在提交规则上产生额外的复杂性是因为所有的日志条目都保留原始的任期号。&lt;/strong&gt;在其他的一致性算法中，如果一个新的领导人要重新复制之前的任期里的日志时，它必须使用当前新的任期号。&lt;strong&gt;Raft 使用的方法更加容易判断出日志，因为他们全程都使用同一个任期号。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;安全性论证&quot;&gt;&lt;a href=&quot;#安全性论证&quot; class=&quot;headerlink&quot; title=&quot;安全性论证&quot;&gt;&lt;/a&gt;安全性论证&lt;/h3&gt;&lt;p&gt;在给定了完整的 Raft 算法之后，我们现在可以更加精确的讨论领导人完全性特性。&lt;strong&gt;我们假设领导人完全性特性不存在的（前提），然&lt;/strong&gt;后我们推出矛盾来。假设任期 T 的领导人（领导人 T）在任期内提交了一条日志条目，但是这条日志条目没有被存储到该领导人未来某个任期的日志中。&lt;strong&gt;设大于 T 的最小任期 U 的领导人 U 没有这条日志条目。&lt;/strong&gt;（三个限制条件，大于T，没有这条日志条目，U最小）&lt;br&gt;&lt;img src=&quot;http://oaewlsdmg.bkt.clouddn.com/image/jpg/Image2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图 9：如果 S1 （任期 T 的领导者）提交了一条新的日志在它的任期里，然后 S5 在之后的任期 U 里被选举为领导人，然后至少会有一个机器，如 S3，既拥有来自 S1 的日志，也给 S5 投票了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;尤其注意前提假设，论证如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在领导人 U 选举的时候一定没有那条被提交的日志条目（领导人从不会删除或者覆盖任何条目）。&lt;/li&gt;
&lt;li&gt;领导人 T 复制这条日志条目给集群中的大多数节点，同时，领导人U 从集群中的大多数节点赢得了选票。因此，至少有一个节点（投票者、选民）同时接受了来自领导人T 的日志条目，并且给领导人U 投票了，如图 9。这个投票者是产生这个矛盾的关键。&lt;/li&gt;
&lt;li&gt;这个投票者必须在【给领导人 U 投票之前】先接受了从领导人 T 发来的已经被提交的日志条目；否则他就会拒绝来自领导人 T 的附加日志请求（因为此时他的任期号会比 T 大）。&lt;/li&gt;
&lt;li&gt;投票者在给领导人 U 投票时依然保有这条日志条目，&lt;strong&gt;因为任何中间的领导人都包含该日志条目（根据上述的假设），&lt;/strong&gt;领导人从不会删除条目，并且跟随者只有和领导人冲突的时候才会删除条目。&lt;/li&gt;
&lt;li&gt;投票者把自己选票投给领导人 U 时，领导人 U 的日志必须和投票者自己一样新。这就导致了两者矛盾之一。&lt;/li&gt;
&lt;li&gt;首先，如果投票者和领导人 U 的最后一条日志的任期号相同，那么领导人 U 的日志至少和投票者一样长，所以领导人 U 的日志一定包含所有投票者的日志。这是另一处矛盾，因为投票者包含了那条已经被提交的日志条目，但是在上述的假设里，领导人 U 是不包含的。&lt;/li&gt;
&lt;li&gt;除此之外，领导人 U 的最后一条日志的任期号就必须比投票人大了。此外，他也比 T 大，因为投票人的最后一条日志的任期号至少和 T 一样大（他包含了来自任期 T 的已提交的日志）。&lt;strong&gt;创建了领导人 U 最后一条日志的之前领导人一定已经包含了那条被提交的日志（根据上述假设，领导人 U 是第一个不包含该日志条目的领导人）。&lt;/strong&gt;所以，根据日志匹配特性，领导人 U 一定也包含那条被提交当然日志，这里产生矛盾。&lt;/li&gt;
&lt;li&gt;这里完成了矛盾。&lt;strong&gt;因此，所有比 T 大的领导人一定包含了所有来自 T 的已经被提交的日志。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;日志匹配原则保证了未来的领导人也同时会包含被间接提交的条目，&lt;/strong&gt;例如图 8 (d) 中的索引 2。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过领导人完全特性，我们就能证明图 3 中的状态机安全特性，&lt;strong&gt;即如果已经服务器已经在某个给定的索引值应用了日志条目到自己的状态机里，那么其他的服务器不会应用一个不一样的日志到同一个索引值上。在一个服务器应用一条日志条目到他自己的状态机中时，他的日志必须和领导人的日志，在该条目和之前的条目上相同，并且已经被提交。&lt;/strong&gt;现在我们来考虑在任何一个服务器应用一个指定索引位置的日志的最小任期；日志完全特性保证拥有更高任期号的领导人会存储相同的日志条目，所以之后的任期里应用某个索引位置的日志条目也会是相同的值。因此，状态机安全特性是成立的。&lt;/p&gt;
&lt;p&gt;最后，Raft 要求服务器按照日志中索引位置顺序应用日志条目。和状态机安全特性结合起来看，这就意味着所有的服务器会应用相同的日志序列集到自己的状态机中，并且是按照相同的顺序。&lt;/p&gt;
&lt;p&gt;-EOF-&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前面的章节里描述了 Raft 算法是如何选举和复制日志的。然而，到目前为止描述的机制并不能充分的保证每一个状态机会按照相同的顺序执行相同的指令。&lt;/strong&gt;例如，一个跟随者可能会进入不可用状态同时领导人已经提交了若干的日志条目，然后这个跟随者可能会被选举为领导人并且覆盖这些日志条目；因此，不同的状态机可能会执行不同的指令序列。&lt;/p&gt;
&lt;p&gt;这一节通过在领导选举的时候增加一些限制来完善了 Raft 算法。&lt;strong&gt;这一限制保证了任何的领导人对于给定的任期号，都拥有了之前任期的所有被提交的日志条目。&lt;/strong&gt;增加这一选举时的限制，我们对于提交时的规则也更加清晰。最终，我们展示对于领导人完整特性的简要证明并且说明领导人是如何领导复制状态机的正确行为的。&lt;br&gt;
    
    </summary>
    
      <category term="Distributed System" scheme="https://zouzls.github.io/categories/Distributed-System/"/>
    
    
      <category term="分布式系统" scheme="https://zouzls.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="算法" scheme="https://zouzls.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Raft" scheme="https://zouzls.github.io/tags/Raft/"/>
    
  </entry>
  
  <entry>
    <title>Raft算法笔记之日志复制（三）</title>
    <link href="https://zouzls.github.io/2016/08/27/Raft%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://zouzls.github.io/2016/08/27/Raft算法笔记之日志复制（三）/</id>
    <published>2016-08-27T08:16:39.000Z</published>
    <updated>2016-08-27T12:40:56.509Z</updated>
    
    <content type="html">&lt;p&gt;Raft算法的日志复制是基于领导人的，如果不清楚领导人选举机制可以阅读上一篇&lt;a href=&quot;http://zouzls.github.io/2016/08/26/Raft%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%A2%86%E5%AF%BC%E4%BA%BA%E9%80%89%E4%B8%BE%EF%BC%88%E4%BA%8C%EF%BC%89/&quot;&gt;领导人选举&lt;/a&gt;。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;新的日志条目&quot;&gt;&lt;a href=&quot;#新的日志条目&quot; class=&quot;headerlink&quot; title=&quot;新的日志条目&quot;&gt;&lt;/a&gt;新的日志条目&lt;/h3&gt;&lt;p&gt;一旦一个领导人被选举出来，他就开始为客户端提供服务。&lt;strong&gt;客户端的每一个请求都包含一条被复制状态机执行的指令。领导人把这条指令作为一条新的日志条目附加到日志中去，然后并行的发起附加条目 RPCs 给其他的服务器，让他们复制这条日志条目。&lt;/strong&gt;当这条日志条目被安全的复制（以后会介绍），领导人会应用这条日志条目到它的状态机中然后把执行的结果返回给客户端。如果跟随者崩溃或者运行缓慢，再或者网络丢包，&lt;strong&gt;领导人会不断的重复尝试附加日志条目 RPCs （尽管已经回复了客户端）直到所有的跟随者都最终存储了所有的日志条目。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oaewlsdmg.bkt.clouddn.com/image/jpg/68747470733a2f2f646e2d307830312d696f2e71626f782e6d652f726166742d254535253942254245362e706e67.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图6：日志由有序序号标记的条目组成。每个条目都包含创建时的任期号（图中框中的数&lt;br&gt;字），和一个状态机需要执行的指令。一个条目当可以安全的被应用到状态机中去的时候&lt;br&gt;，就认为是可以提交了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;日志以上图展示的方式组织。每一个日志条目存储一条状态机指令和从领导人收到这条指令时的任期号。在日志中的任期号是用来检查不一致情况。每一条日志条目同时也都有一个整数索引值来表明它在日志中的位置。&lt;/p&gt;
&lt;h3 id=&quot;已提交日志条目&quot;&gt;&lt;a href=&quot;#已提交日志条目&quot; class=&quot;headerlink&quot; title=&quot;已提交日志条目&quot;&gt;&lt;/a&gt;已提交日志条目&lt;/h3&gt;&lt;p&gt;领导人来决定什么时候把日志条目应用到状态机中是安全的，这种日志条目被称为已提交。&lt;strong&gt;Raft 算法保证所有已提交的日志条目都是持久化的并且最终会被所有可用的状态机执行。在领导人将创建的日志条目复制到大多数的服务器上的时候，日志条目就会被提交（例如在上图中的条目 7）&lt;/strong&gt;。同时，领导人的日志中之前的所有日志条目也都会被提交，包括由其他领导人创建的条目。后面安全性会讨论某些当在领导人改变之后应用这条规则的隐晦内容，同时他也展示了这种提交的定义是安全的。&lt;strong&gt;领导人跟踪了最大的将会被提交的日志项的索引，并且索引值会被包含在未来的所有附加日志 RPCs（包括心跳包），这样其他的服务器才能最终知道领导人的提交位置。&lt;/strong&gt;一旦跟随者知道一条日志条目已经被提交，那么他也会将这个日志条目应用到本地的状态机中（按照日志的顺序）。&lt;/p&gt;
&lt;h3 id=&quot;日志匹配特性&quot;&gt;&lt;a href=&quot;#日志匹配特性&quot; class=&quot;headerlink&quot; title=&quot;日志匹配特性&quot;&gt;&lt;/a&gt;日志匹配特性&lt;/h3&gt;&lt;p&gt;我们设计了 Raft 的日志机制来维护一个不同服务器的日志之间的高层次的一致性。这么做不仅简化了系统的行为也使得更加可预计，同时他也是安全性保证的一个重要组件。Raft 维护着以下的特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们存储了相同的指令。&lt;/li&gt;
&lt;li&gt;如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们之前的所有日志条目也全部相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一个特性来自这样的一个事实，领导人最多在一个任期里在指定的一个日志索引位置创建一条日志条目，同时日志条目在日志中的位置也从来不会改变。&lt;strong&gt;第二个特性由附加日志 RPC 的一个简单的一致性检查所保证。在发送附加日志 RPC 的时候，领导人会把新的日志条目紧接着之前的条目的索引位置和任期号包含在里面。如果跟随者在它的日志中找不到包含相同索引位置和任期号的条目，那么他就会拒绝接收新的日志条目。&lt;/strong&gt;一致性检查就像一个归纳步骤：一开始空的日志状态肯定是满足日志匹配特性的，然后一致性检查保护了日志匹配特性当日志扩展的时候。因此，每当附加日志 RPC 返回成功时，领导人就知道跟随者的日志一定是和自己相同的了。&lt;/p&gt;
&lt;h3 id=&quot;当领导人与跟随者日志不一致&quot;&gt;&lt;a href=&quot;#当领导人与跟随者日志不一致&quot; class=&quot;headerlink&quot; title=&quot;当领导人与跟随者日志不一致&quot;&gt;&lt;/a&gt;当领导人与跟随者日志不一致&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://oaewlsdmg.bkt.clouddn.com/blog/image/68747470733a2f2f646e2d307830312d696f2e71626f782e6d652f726166742d254535253942254245372e706e67.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图7：当一个领导人成功当选时，跟随者可能是任何情况（a-f）。每一个盒子表示是一个日志条目；里面的数字表示任期号。跟随者可能会缺少一些日志条目（a-b），可能会有一些未被提交的日志条目（c-d），或者两种情况都存在（e-f）。例如，场景 f 可能这样发生，那个服务器在任期 2 的时候是领导人，附加了一些日志条目到自己的日志中，在提交之前就崩溃了；很快这个机器就重启了，在任期 3 重新被选为领导人，并且又增加了一些日志条目到自己的日志中；在这些任期 2 和任期 3 重点日志被提交之前，这个服务器又宕机了，然后的几个任期里一直处于宕机状态&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在正常的操作中，领导人和跟随者的日志保持一致性，所以附加日志 RPC 的一致性检查从来不会失败。然而，领导人崩溃的情况会使得日志处于不一致的状态（老的领导人可能还没有完全复制所有的日志条目）。这种不一致问题会在一系列的领导人和跟随者崩溃的情况下加剧。图 7 展示了跟随者的日志可能和新的领导人不同的方式。跟随者可能会丢失一些在新的领导人中有的日志条目，他也可能拥有一些领导人没有的日志条目，或者两者都发生。丢失或者多出日志条目可能会持续多个任期。&lt;/p&gt;
&lt;h3 id=&quot;领导人处理不一致是通过强制复制&quot;&gt;&lt;a href=&quot;#领导人处理不一致是通过强制复制&quot; class=&quot;headerlink&quot; title=&quot;领导人处理不一致是通过强制复制&quot;&gt;&lt;/a&gt;领导人处理不一致是通过强制复制&lt;/h3&gt;&lt;p&gt;在 Raft 算法中，领导人处理不一致是通过强制跟随者直接复制自己的日志来解决了。这意味着在跟随者中的冲突的日志条目会被领导人的日志覆盖。下一篇会阐述如何通过增加一些限制来使得这样的操作是安全的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要使得跟随者的日志进入和自己一致的状态，领导人必须找到最后两者达成一致的地方，然后删除从那个点之后的所有日志条目，发送自己的日志给跟随者。所有的这些操作都在进行附加日志 RPCs 的一致性检查时完成。&lt;/strong&gt;领导人针对每一个跟随者维护了一个 nextIndex，这表示下一个需要发送给跟随者的日志条目的索引地址。当一个领导人刚获得权力的时候，他初始化所有的 nextIndex 值为自己日志中的最后一条（图 7 中的 11）。如果一个跟随者的日志和领导人不一致，那么在下一次的附加日志 RPC 时的一致性检查就会失败。在被跟随者拒绝之后，领导人就会减小 nextIndex 值并进行重试。最终 nextIndex 会在某个位置使得领导人和跟随者的日志达成一致。&lt;strong&gt;当这种情况发生，附加日志 RPC 就会成功，这时就会把跟随者冲突的日志条目全部删除并且加上领导人的日志。&lt;/strong&gt;一旦附加日志 RPC 成功，那么跟随者的日志就会和领导人保持一致，并且在接下来的任期里一直继续保持。&lt;/p&gt;
&lt;h3 id=&quot;解决冲突的性能优化&quot;&gt;&lt;a href=&quot;#解决冲突的性能优化&quot; class=&quot;headerlink&quot; title=&quot;解决冲突的性能优化&quot;&gt;&lt;/a&gt;解决冲突的性能优化&lt;/h3&gt;&lt;p&gt;如果需要的话，算法可以通过减少被拒绝的附加日志 RPCs 的次数来优化。例如，当附加日志 RPC 的请求被拒绝的时候，跟随者可以包含冲突的条目的任期号和自己存储的那个任期的最早的索引地址。借助这些信息，领导人可以减小 nextIndex 越过所有那个任期冲突的所有日志条目；这样就变成每个任期需要一次附加条目 RPC 而不是每个条目一次。在实践中，我们十分怀疑这种优化是否是必要的，因为失败是很少发生的并且也不大可能会有这么多不一致的日志。&lt;/p&gt;
&lt;p&gt;通过这种机制，领导人在获得权力的时候就不需要任何特殊的操作来恢复一致性。他只需要进行正常的操作，然后日志就能自动的在回复附加日志 RPC 的一致性检查失败的时候自动趋于一致。&lt;strong&gt;领导人从来不会覆盖或者删除自己的日志&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;日志复制机制展示出了一致性特性：Raft 能够接受，复制并应用新的日志条目只要大部分的机器是工作的；&lt;strong&gt;在通常的情况下，新的日志条目可以在一次 RPC 中被复制给集群中的大多数机器；&lt;/strong&gt;并且单个的缓慢的跟随者不会影响整体的性能。&lt;/p&gt;
&lt;p&gt;-EOF-&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Raft算法的日志复制是基于领导人的，如果不清楚领导人选举机制可以阅读上一篇&lt;a href=&quot;http://zouzls.github.io/2016/08/26/Raft%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%A2%86%E5%AF%BC%E4%BA%BA%E9%80%89%E4%B8%BE%EF%BC%88%E4%BA%8C%EF%BC%89/&quot;&gt;领导人选举&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="Distributed System" scheme="https://zouzls.github.io/categories/Distributed-System/"/>
    
    
      <category term="分布式系统" scheme="https://zouzls.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="算法" scheme="https://zouzls.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Raft" scheme="https://zouzls.github.io/tags/Raft/"/>
    
  </entry>
  
  <entry>
    <title>Raft算法笔记之领导人选举（二）</title>
    <link href="https://zouzls.github.io/2016/08/26/Raft%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%A2%86%E5%AF%BC%E4%BA%BA%E9%80%89%E4%B8%BE%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://zouzls.github.io/2016/08/26/Raft算法笔记之领导人选举（二）/</id>
    <published>2016-08-26T12:55:27.000Z</published>
    <updated>2016-08-26T15:21:55.424Z</updated>
    
    <content type="html">&lt;p&gt;Raft算法作者在设计算法过程中为了提升算法可理解性，决定将算法分解为三个模块，分别是领导人选举、日志复制和安全性证明。这种将一个大问题分解成小问题的思路还是不错的，所以我姑且将一篇大论文分成几篇小博文来单独分析，希望能得作者心法真传。本篇主要内容是领导人选举。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Raft-基础知识&quot;&gt;&lt;a href=&quot;#Raft-基础知识&quot; class=&quot;headerlink&quot; title=&quot;Raft 基础知识&quot;&gt;&lt;/a&gt;Raft 基础知识&lt;/h3&gt;&lt;h4 id=&quot;状态&quot;&gt;&lt;a href=&quot;#状态&quot; class=&quot;headerlink&quot; title=&quot;状态&quot;&gt;&lt;/a&gt;状态&lt;/h4&gt;&lt;p&gt;一个 Raft 集群包含若干个服务器节点；通常是 5 个，这允许整个系统容忍 2 个节点的失效。在任何时刻，每一个服务器节点都处于这三个状态之一：&lt;strong&gt;领导人、跟随者或者候选人。&lt;/strong&gt;&lt;br&gt;在通常情况下，系统中只有一个领导人并且其他的节点全部都是跟随者。跟随者都是被动的：他们不会发送任何请求，只是简单的响应来自领导者或者候选人的请求。领导人处理所有的客户端请求（如果一个客户端和跟随者联系，那么跟随者会把请求重定向给领导人）。第三种状态，候选人，是用来描述的选举新领导人时使用。&lt;/p&gt;
&lt;h4 id=&quot;任期&quot;&gt;&lt;a href=&quot;#任期&quot; class=&quot;headerlink&quot; title=&quot;任期&quot;&gt;&lt;/a&gt;任期&lt;/h4&gt;&lt;p&gt;Raft 把时间分割成任意长度的任期，如下图。任期用连续的整数标记。每一段任期从一次选举开始，一个或者多个候选人尝试成为领导者。如果一个候选人赢得选举，然后他就在接下来的任期内充当领导人的职责。在某些情况下，一次选举过程会造成选票的瓜分。在这种情况下，这一任期会以没有领导人结束；一个新的任期（和一次新的选举）会很快重新开始。Raft 保证了在一个给定的任期内，最多只有一个领导者。&lt;br&gt;&lt;img src=&quot;http://oaewlsdmg.bkt.clouddn.com/image/jpg/68747470733a2f2f646e2d307830312d696f2e71626f782e6d652f726166742d254535253942254245352e706e67.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;任期号&quot;&gt;&lt;a href=&quot;#任期号&quot; class=&quot;headerlink&quot; title=&quot;任期号&quot;&gt;&lt;/a&gt;任期号&lt;/h4&gt;&lt;p&gt;不同的服务器节点可能多次观察到任期之间的转换，但在某些情况下，一个节点也可能观察不到任何一次选举或者整个任期全程。任期在 Raft 算法中充当逻辑时钟的作用，这会允许服务器节点查明一些过期的信息比如陈旧的领导者。每一个节点存储一个当前任期号，这一编号在整个时期内单调的增长。当服务器之间通信的时候会交换当前任期号；如果一个服务器的当前任期号比其他人小，那么他会更新自己的编号到较大的编号值。如果一个候选人或者领导者发现自己的任期号过期了，那么他会立即恢复成跟随者状态。如果一个节点接收到一个包含过期的任期号的请求，那么他会直接拒绝这个请求。&lt;/p&gt;
&lt;h4 id=&quot;RPCs&quot;&gt;&lt;a href=&quot;#RPCs&quot; class=&quot;headerlink&quot; title=&quot;RPCs&quot;&gt;&lt;/a&gt;RPCs&lt;/h4&gt;&lt;p&gt;Raft 算法中服务器节点之间通信使用远程过程调用（RPCs），并且基本的一致性算法只需要两种类型的 RPCs。请求投票（RequestVote） RPCs 由候选人在选举期间发起，然后附加条目（AppendEntries）RPCs 由领导人发起，用来复制日志和提供一种心跳机制。为了在服务器之间传输快照增加了第三种 RPC。当服务器没有及时的收到 RPC 的响应时，会进行重试， 并且他们能够并行的发起 RPCs 来获得最佳的性能。&lt;/p&gt;
&lt;h3 id=&quot;领导人选举&quot;&gt;&lt;a href=&quot;#领导人选举&quot; class=&quot;headerlink&quot; title=&quot;领导人选举&quot;&gt;&lt;/a&gt;领导人选举&lt;/h3&gt;&lt;h4 id=&quot;跟随者到候选人&quot;&gt;&lt;a href=&quot;#跟随者到候选人&quot; class=&quot;headerlink&quot; title=&quot;跟随者到候选人&quot;&gt;&lt;/a&gt;跟随者到候选人&lt;/h4&gt;&lt;p&gt;Raft 使用一种心跳机制来触发领导人选举。当服务器程序启动时，他们都是跟随者身份。一个服务器节点要想继续保持着跟随者状态除非他从领导人或者候选者处接收到有效的 RPCs。领导者周期性的向所有跟随者发送心跳包（不包含日志项内容的附加日志项 RPCs）来维持自己的权威。如果一个跟随者在一段时间里没有接收到任何消息，也就是选举超时，然后他就会认为系统中没有可用的领导者然后开始进行选举以选出新的领导者。&lt;br&gt;要开始一次选举过程，跟随者先要增加自己的当前任期号并且转换到候选人状态。然后他会并行的向集群中的其他服务器节点发送请求投票的 RPCs 来给自己投票。候选人会继续保持着当前状态直到以下三件事情之一发生：(a) 他自己赢得了这次的选举，(b) 其他的服务器成为领导者，(c) 一段时间之后没有任何一个获胜的人。这些结果会分别的在下面的段落里进行讨论。&lt;/p&gt;
&lt;h4 id=&quot;候选人的三种结局&quot;&gt;&lt;a href=&quot;#候选人的三种结局&quot; class=&quot;headerlink&quot; title=&quot;候选人的三种结局&quot;&gt;&lt;/a&gt;候选人的三种结局&lt;/h4&gt;&lt;h5 id=&quot;赢得这次选举&quot;&gt;&lt;a href=&quot;#赢得这次选举&quot; class=&quot;headerlink&quot; title=&quot;赢得这次选举&quot;&gt;&lt;/a&gt;赢得这次选举&lt;/h5&gt;&lt;p&gt;当一个候选人从整个集群的大多数服务器节点获得了针对同一个任期号的选票，那么他就赢得了这次选举并成为领导人。每一个服务器最多会对一个任期号投出一张选票，按照先来先服务的原则（注意：5.4 节在投票上增加了一点额外的限制）。要求大多数选票的规则确保了最多只会有一个候选人赢得此次选举（图 3 中的选举安全性）。一旦候选人赢得选举，他就立即成为领导人。然后他会向其他的服务器发送心跳消息来建立自己的权威并且阻止新的领导人的产生。&lt;/p&gt;
&lt;h5 id=&quot;其他服务器赢得选举&quot;&gt;&lt;a href=&quot;#其他服务器赢得选举&quot; class=&quot;headerlink&quot; title=&quot;其他服务器赢得选举&quot;&gt;&lt;/a&gt;其他服务器赢得选举&lt;/h5&gt;&lt;p&gt;在等待投票的时候，候选人可能会从其他的服务器接收到声明它是领导人的附加日志项 RPC。如果这个领导人的任期号（包含在此次的 RPC中）不小于候选人当前的任期号，那么候选人会承认领导人合法并回到跟随者状态。 如果此次 RPC 中的任期号比自己小，那么候选人就会拒绝这次的 RPC 并且继续保持候选人状态。&lt;/p&gt;
&lt;h5 id=&quot;选票瓜分，不赢不输&quot;&gt;&lt;a href=&quot;#选票瓜分，不赢不输&quot; class=&quot;headerlink&quot; title=&quot;选票瓜分，不赢不输&quot;&gt;&lt;/a&gt;选票瓜分，不赢不输&lt;/h5&gt;&lt;p&gt;第三种可能的结果是候选人既没有赢得选举也没有输：如果有多个跟随者同时成为候选人，那么选票可能会被瓜分以至于没有候选人可以赢得大多数人的支持。当这种情况发生的时候，每一个候选人都会超时，然后通过增加当前任期号来开始一轮新的选举。然而，没有其他机制的话，选票可能会被无限的重复瓜分。&lt;/p&gt;
&lt;h4 id=&quot;关于随机选举超时时间讨论&quot;&gt;&lt;a href=&quot;#关于随机选举超时时间讨论&quot; class=&quot;headerlink&quot; title=&quot;关于随机选举超时时间讨论&quot;&gt;&lt;/a&gt;关于随机选举超时时间讨论&lt;/h4&gt;&lt;p&gt;Raft 算法使用随机选举超时时间的方法来确保很少会发生选票瓜分的情况，就算发生也能很快的解决。为了阻止选票起初就被瓜分，选举超时时间是从一个固定的区间（例如 150-300毫秒）随机选择。这样可以把服务器都分散开以至于在大多数情况下只有一个服务器会选举超时；然后他赢得选举并在其他服务器超时之前发送心跳包。同样的机制被用在选票瓜分的情况下。每一个候选人在开始一次选举的时候会重置一个随机的选举超时时间，然后在下次选举之前一直等待；这样减少了在新的选举中另外的选票瓜分的可能性。9.3 节展示了这种方案能够快速的选出一个领导人。我们针对算法进行了多次调整，但是每次调整之后都会有新的问题。最终我们认为随机重试的方法是更加明显和易于理解的。&lt;/p&gt;
&lt;p&gt;-EOF-&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Raft算法作者在设计算法过程中为了提升算法可理解性，决定将算法分解为三个模块，分别是领导人选举、日志复制和安全性证明。这种将一个大问题分解成小问题的思路还是不错的，所以我姑且将一篇大论文分成几篇小博文来单独分析，希望能得作者心法真传。本篇主要内容是领导人选举。&lt;br&gt;
    
    </summary>
    
      <category term="Distributed System" scheme="https://zouzls.github.io/categories/Distributed-System/"/>
    
    
      <category term="分布式系统" scheme="https://zouzls.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="算法" scheme="https://zouzls.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Raft" scheme="https://zouzls.github.io/tags/Raft/"/>
    
  </entry>
  
  <entry>
    <title>Raft算法笔记（一）</title>
    <link href="https://zouzls.github.io/2016/08/26/Raft%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://zouzls.github.io/2016/08/26/Raft算法笔记（一）/</id>
    <published>2016-08-26T07:04:16.000Z</published>
    <updated>2016-08-26T13:26:34.176Z</updated>
    
    <content type="html">&lt;p&gt;之前记得微博上有个博主在关于知乎上讨论「精通C++语言是一种怎样的体验」的时候，评论了一句，印象很深刻，刚刚翻出来有看了一下，原话是：“建议青年学子多把时间花在基础理论「算法，操作系统，编译原理」和具体领域「数据库，分布式系统，并发编程，机器学习」”，私以为是有几分道理的，然后最近不知怎么就对分布式感兴趣起来了。技术学习无止境，但是保持好奇心和敏锐度，总是需要的。&lt;br&gt;本文是浓缩版（虽然我觉得原论文写得更好，没有一句废话），主要是记录在阅读Raft算法过程中的理解和笔记，方便日后回头温习，如果感兴趣并且条件允许可以阅读论文原文和论文中文翻译，见文末参考资料。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;一致性问题和一致性算法&quot;&gt;&lt;a href=&quot;#一致性问题和一致性算法&quot; class=&quot;headerlink&quot; title=&quot;一致性问题和一致性算法&quot;&gt;&lt;/a&gt;一致性问题和一致性算法&lt;/h3&gt;&lt;p&gt;分布式系统的一个主要问题就是一致性问题，通俗的理解就是如何使一组服务器中的每个成员数据保持一致，当其中某个服务器收到客户端的一组指令时,它必须与其它服务器交流以保证所有的服务器都是以同样的顺序收到同样的指令,这样的话所有的服务器会产生一致的结果,看起来就像是一台机器一样。&lt;br&gt;为了解决这个问题而出现的解决方案就是一致性算法，一致性算法允许一组机器像一个整体一样工作，即使其中一些机器出现故障也能够继续工作下去。正因为如此，一致性算法在构建可信赖的大规模软件系统中扮演着重要的角色。&lt;br&gt;在过去的 10 年里，Paxos 算法统治着一致性算法这一领域。但是Paxos太难理解了，折磨了不少学生和开发者等等，于是有人受不了了看不下去了，决定改变这种局面，于是Raft算法这种更加具有亲和力和接地气的算法应运而生，得天时地利人和。作者是来自Stanford University的Professor：Diego Ongaro 和 John Ousterhout。&lt;/p&gt;
&lt;h3 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h3&gt;&lt;p&gt;Raft 是一种为了管理复制日志的一致性算法。它提供了和 Paxos 算法相同的功能和性能，但是它的算法结构和 Paxos 不同，使得 Raft 算法更加容易理解并且更容易构建实际的系统。为了提升可理解性，Raft 将一致性算法分解成了几个关键模块，例如领导人选举、日志复制和安全性。同时它通过实施一个更强的一致性来减少需要考虑的状态的数量。从一个用户研究的结果可以证明，对于学生而言，Raft 算法比 Paxos 算法更加容易学习。Raft 算法还包括一个新的机制来允许集群成员的动态改变，它利用重叠的大多数来保证安全性。&lt;/p&gt;
&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;h4 id=&quot;首要目标是可理解性&quot;&gt;&lt;a href=&quot;#首要目标是可理解性&quot; class=&quot;headerlink&quot; title=&quot;首要目标是可理解性&quot;&gt;&lt;/a&gt;首要目标是可理解性&lt;/h4&gt;&lt;p&gt;Raft设计的首要目标是可理解性：我们是否可以在实际系统中定义一个一致性算法，并且能够比 Paxos 算法以一种更加容易的方式来学习。此外，我们希望该算法方便系统构建者的直觉的发展。不仅一个算法能够工作很重要，而且能够显而易见的知道为什么能工作也很重要。&lt;/p&gt;
&lt;h4 id=&quot;如何提升可理解性&quot;&gt;&lt;a href=&quot;#如何提升可理解性&quot; class=&quot;headerlink&quot; title=&quot;如何提升可理解性&quot;&gt;&lt;/a&gt;如何提升可理解性&lt;/h4&gt;&lt;p&gt;我们使用一些特别的技巧来提升它的可理解性，包括算法分解（Raft 主要被分成了领导人选举，日志复制和安全三个模块）和减少状态机的状态（相对于 Paxos，Raft 减少了非确定性和服务器互相处于非一致性的方式）。&lt;/p&gt;
&lt;h4 id=&quot;Raft的独特特性&quot;&gt;&lt;a href=&quot;#Raft的独特特性&quot; class=&quot;headerlink&quot; title=&quot;Raft的独特特性&quot;&gt;&lt;/a&gt;Raft的独特特性&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;强领导者：&lt;br&gt;和其他一致性算法相比，Raft 使用一种更强的领导能力形式。比如，日志条目只从领导者发送给其他的服务器。这种方式简化了对复制日志的管理并且使得 Raft 算法更加易于理解。&lt;/li&gt;
&lt;li&gt;领导选举：&lt;br&gt;Raft 算法使用一个随机计时器来选举领导者。这种方式只是在任何一致性算法都必须实现的心跳机制上增加了一点机制。在解决冲突的时候会更加简单快捷。&lt;/li&gt;
&lt;li&gt;关系调整：&lt;br&gt;Raft 使用一种共同一致的方法来处理集群成员变换的问题，在这种方法中，两种不同的配置都要求的大多数机器会重叠。这就使得集群在成员变换的时候依然可以继续工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;复制状态机&quot;&gt;&lt;a href=&quot;#复制状态机&quot; class=&quot;headerlink&quot; title=&quot;复制状态机&quot;&gt;&lt;/a&gt;复制状态机&lt;/h3&gt;&lt;h4 id=&quot;一致性算法的提出背景&quot;&gt;&lt;a href=&quot;#一致性算法的提出背景&quot; class=&quot;headerlink&quot; title=&quot;一致性算法的提出背景&quot;&gt;&lt;/a&gt;一致性算法的提出背景&lt;/h4&gt;&lt;p&gt;一致性算法是从复制状态机的背景下提出的。在这种方法中，一组服务器上的状态机产生相同状态的副本，并且在一些机器宕掉的情况下也可以继续运行。复制状态机在分布式系统中被用于解决很多容错的问题。例如，大规模的系统中通常都有一个集群领导者，像 GFS、HDFS 和 RAMCloud，十分典型的使用一个单独的复制状态机去管理领导选举和存储配置信息并且在领导人宕机的情况下也要存活下来。比如 Chubby 和 ZooKeeper。&lt;/p&gt;
&lt;h4 id=&quot;基于复制日志实现&quot;&gt;&lt;a href=&quot;#基于复制日志实现&quot; class=&quot;headerlink&quot; title=&quot;基于复制日志实现&quot;&gt;&lt;/a&gt;基于复制日志实现&lt;/h4&gt;&lt;p&gt;复制状态机通常都是基于复制日志实现的。每一个服务器存储一个包含一系列指令的日志，并且按照日志的顺序进行执行。每一个日志都按照相同的顺序包含相同的指令，所以每一个服务器都执行相同的指令序列。因为每个状态机都是确定的，每一次执行操作都产生相同的状态和同样的序列。&lt;/p&gt;
&lt;h4 id=&quot;保证复制日志相同&quot;&gt;&lt;a href=&quot;#保证复制日志相同&quot; class=&quot;headerlink&quot; title=&quot;保证复制日志相同&quot;&gt;&lt;/a&gt;保证复制日志相同&lt;/h4&gt;&lt;p&gt;保证复制日志相同就是一致性算法的工作了。在一台服务器上，一致性模块接收客户端发送来的指令然后增加到自己的日志中去。它和其他服务器上的一致性模块进行通信来保证每一个服务器上的日志最终都以相同的顺序包含相同的请求，尽管有些服务器会宕机。一旦指令被正确的复制，每一个服务器的状态机按照日志顺序处理他们，然后输出结果被返回给客户端。因此，服务器集群看起来形成一个高可靠的状态机。&lt;/p&gt;
&lt;h3 id=&quot;为了可理解性的设计&quot;&gt;&lt;a href=&quot;#为了可理解性的设计&quot; class=&quot;headerlink&quot; title=&quot;为了可理解性的设计&quot;&gt;&lt;/a&gt;为了可理解性的设计&lt;/h3&gt;&lt;h4 id=&quot;设计Raft的几个初衷：&quot;&gt;&lt;a href=&quot;#设计Raft的几个初衷：&quot; class=&quot;headerlink&quot; title=&quot;设计Raft的几个初衷：&quot;&gt;&lt;/a&gt;设计Raft的几个初衷：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;它必须提供一个完整的实际的系统实现基础，这样才能大大减少开发者的工作；&lt;/li&gt;
&lt;li&gt;它必须在任何情况下都是安全的并且在大多数的情况下都是可用的；&lt;/li&gt;
&lt;li&gt;并且它的大部分操作必须是高效的。&lt;/li&gt;
&lt;li&gt;但是我们最重要也是最大的挑战是可理解性。它必须保证对于普遍的人群都可以十分容易的去理解。&lt;/li&gt;
&lt;li&gt;另外，它必须能够让人形成直观的认识，这样系统的构建者才能够在现实中进行必然的扩展。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;解决可理解性的问题&quot;&gt;&lt;a href=&quot;#解决可理解性的问题&quot; class=&quot;headerlink&quot; title=&quot;解决可理解性的问题&quot;&gt;&lt;/a&gt;解决可理解性的问题&lt;/h4&gt;&lt;p&gt;我们意识到对这种可理解性分析上具有高度的主观性；尽管如此，我们使用了两种通常适用的技术来解决这个问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个技术就是众所周知的问题分解：&lt;br&gt;只要有可能，我们就将问题分解成几个相对独立的，可被解决的、可解释的和可理解的子问题。例如，Raft 算法被我们分成领导人选举，日志复制，安全性和角色改变几个部分。&lt;/li&gt;
&lt;li&gt;第二个方法是通过减少状态的数量：&lt;br&gt;来简化需要考虑的状态空间，使得系统更加连贯并且在可能的时候消除不确定性。尤其是，随机化方法增加了不确定性，但是他们有利于减少状态空间数量，通过处理所有可能选择时使用相似的方法。我们使用随机化去简化 Raft 中领导人选举算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Raft一致性算法&quot;&gt;&lt;a href=&quot;#Raft一致性算法&quot; class=&quot;headerlink&quot; title=&quot;Raft一致性算法&quot;&gt;&lt;/a&gt;Raft一致性算法&lt;/h3&gt;&lt;p&gt;Raft 通过选举一个高贵的领导人，然后给予他全部的管理复制日志的责任来实现一致性。领导人从客户端接收日志条目，把日志条目复制到其他服务器上，并且当保证安全性的时候告诉其他的服务器应用日志条目到他们的状态机中。拥有一个领导人大大简化了对复制日志的管理。例如，领导人可以决定新的日志条目需要放在日志中的什么位置而不需要和其他服务器商议，并且数据都从领导人流向其他服务器。一个领导人可以宕机，可以和其他服务器失去连接，这时一个新的领导人会被选举出来。&lt;br&gt;通过领导人的方式，Raft 将一致性问题分解成了三个相对独立的子问题，这些问题会在接下来的子章节中进行讨论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;领导选举：&lt;br&gt;一个新的领导人需要被选举出来，当先存的领导人宕机的时候。&lt;/li&gt;
&lt;li&gt;日志复制：&lt;br&gt;领导人必须从客户端接收日志然后复制到集群中的其他节点，并且强制要求其他节点的日志保持和自己相同。&lt;/li&gt;
&lt;li&gt;安全性：&lt;br&gt;在 Raft 中安全性的关键是状态机安全：如果有任何的服务器节点已经应用了一个确定的日志条目到它的状态机中，那么其他服务器节点不能在同一个日志索引位置应用一个不同的指令。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这篇先到这儿，后面再具体分析每个部分，领导人选举、日志复制和安全性，在这之前可以看看&lt;a href=&quot;http://thesecretlivesofdata.com/raft/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Raft协议的动画演示&lt;/a&gt;，会对接下来的理解起到帮助作用。&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Raft论文英文&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Raft论文中文翻译&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;-EOF-&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;之前记得微博上有个博主在关于知乎上讨论「精通C++语言是一种怎样的体验」的时候，评论了一句，印象很深刻，刚刚翻出来有看了一下，原话是：“建议青年学子多把时间花在基础理论「算法，操作系统，编译原理」和具体领域「数据库，分布式系统，并发编程，机器学习」”，私以为是有几分道理的，然后最近不知怎么就对分布式感兴趣起来了。技术学习无止境，但是保持好奇心和敏锐度，总是需要的。&lt;br&gt;本文是浓缩版（虽然我觉得原论文写得更好，没有一句废话），主要是记录在阅读Raft算法过程中的理解和笔记，方便日后回头温习，如果感兴趣并且条件允许可以阅读论文原文和论文中文翻译，见文末参考资料。&lt;br&gt;
    
    </summary>
    
      <category term="Distributed System" scheme="https://zouzls.github.io/categories/Distributed-System/"/>
    
    
      <category term="分布式系统" scheme="https://zouzls.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="算法" scheme="https://zouzls.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Raft" scheme="https://zouzls.github.io/tags/Raft/"/>
    
  </entry>
  
  <entry>
    <title>Docker安装与启动</title>
    <link href="https://zouzls.github.io/2016/07/27/Docker%E5%AE%89%E8%A3%85%E4%B8%8E%E5%90%AF%E5%8A%A8/"/>
    <id>https://zouzls.github.io/2016/07/27/Docker安装与启动/</id>
    <published>2016-07-27T05:43:33.000Z</published>
    <updated>2016-08-26T10:38:23.591Z</updated>
    
    <content type="html">&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;第一次听到docker这个词是15年7月份，老板让项目组老大看看docker相关技术，据说是可以提高公司项目部署的效率，不过遗憾的是的当时已经准备快离职了，所以没能早一点一睹docker容器的庐山真面目。现在看来docker的热度也不是一年之前能比的了，不过也激发了我对技术的好奇心，决定挖这样一个坑，来激励自己去研究一下docker的内部原理和实际应用。本篇文章记录安装过程中出现的一些问题和解决过程，重点在于启动过程中的几个错误。&lt;br&gt;注：不同的系统和硬件环境下安装文件和过程不太一样，所以:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;采用Docker Toolbox方式安装的请绕行。&lt;/li&gt;
&lt;li&gt;以下适用于Docker for Windows Beta的安装，详情请看下面「安装-环境要求」。&lt;/li&gt;
&lt;/ol&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;h4 id=&quot;环境要求（非常重要！）&quot;&gt;&lt;a href=&quot;#环境要求（非常重要！）&quot; class=&quot;headerlink&quot; title=&quot;环境要求（非常重要！）&quot;&gt;&lt;/a&gt;环境要求（非常重要！）&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;系统环境&lt;br&gt;64bit Windows 10 Pro, Enterprise and Education (1511 November update, Build 10586 or later)。在cortana输入框键入winver，然后回车enter即可查看系统版本。&lt;/li&gt;
&lt;li&gt;内存大小&lt;br&gt;最好是&amp;gt;4G内存,后面为docker分配的内存至少是1G，太小的内存可能导致启动不成功。&lt;/li&gt;
&lt;li&gt;Hyper-V开启&lt;br&gt;如果不支持Hyper-V虚拟化，就只能用 Docker Toolbox方式安装了。查看是否支持Hyper-V方式如下，打开「任务管理器-性能」，默认是禁用的（如何开启见下方「启动-关于虚拟化未开启错误」），如下：&lt;br&gt;&lt;img src=&quot;http://oaewlsdmg.bkt.clouddn.com/image/jpg/3bf33a87e950352a23e067375043fbf2b2118b08.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;下载-amp-安装&quot;&gt;&lt;a href=&quot;#下载-amp-安装&quot; class=&quot;headerlink&quot; title=&quot;下载&amp;amp;安装&quot;&gt;&lt;/a&gt;下载&amp;amp;安装&lt;/h4&gt;&lt;p&gt;进入&lt;a href=&quot;https://docs.docker.com/docker-for-windows/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;页面&lt;/a&gt;，点击Get Docker for Windows，下载完InstallDocker.msi文件直接安装即可，直到finish（launch Docker默认打勾），安装过程很快。&lt;/p&gt;
&lt;h3 id=&quot;启动&quot;&gt;&lt;a href=&quot;#启动&quot; class=&quot;headerlink&quot; title=&quot;启动&quot;&gt;&lt;/a&gt;启动&lt;/h3&gt;&lt;h4 id=&quot;关于「虚拟化未开启」错误&quot;&gt;&lt;a href=&quot;#关于「虚拟化未开启」错误&quot; class=&quot;headerlink&quot; title=&quot;关于「虚拟化未开启」错误&quot;&gt;&lt;/a&gt;关于「虚拟化未开启」错误&lt;/h4&gt;&lt;p&gt;安装完之后docker会尝试第一次启动，如果电脑Hyper-V之前未开启，docker会提示开启Hyper-V并且电脑随即进入重启，我在重启的时候忘记进入BIOS设置了，结果重启完之后，（因为docker安装完是设置开机自启动的）docker启动的时候就出现下面错误了。&lt;br&gt;&lt;strong&gt;解决方式&lt;/strong&gt;：再次重启，并且过程中进入BIOS，不同的电脑进入BIOS方式不同，Lenovo是按住F2，照下图操作即可：&lt;br&gt;&lt;img src=&quot;http://oaewlsdmg.bkt.clouddn.com/image/jpg/192152313325897.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;关于「Unable-…Exit-1」错误&quot;&gt;&lt;a href=&quot;#关于「Unable-…Exit-1」错误&quot; class=&quot;headerlink&quot; title=&quot;关于「Unable …Exit 1」错误&quot;&gt;&lt;/a&gt;关于「Unable …Exit 1」错误&lt;/h4&gt;&lt;p&gt;当你觉得修改完BIOS，觉得已经万事大吉的时候，再重新Start docker的时候，可能又会如下错误，我在docker（1.12.0） build 5579的版本中遇到，错误码如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Unable to write to the database. Exit 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方式&lt;/strong&gt;：打开网络与共享中心，可以看到多了一个关于docker虚拟机的vEthernet（DockerNAT）连接，点击进入，配置虚拟机的DNS网关并且禁用IPV6，如图：&lt;br&gt;&lt;img src=&quot;http://oaewlsdmg.bkt.clouddn.com/image/jpg/QQ%E6%88%AA%E5%9B%BE20160727152117.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;配置完之后，再启动错误码就会消失了。&lt;/p&gt;
&lt;h4 id=&quot;关于「Not-enough-memory」错误&quot;&gt;&lt;a href=&quot;#关于「Not-enough-memory」错误&quot; class=&quot;headerlink&quot; title=&quot;关于「Not enough memory」错误&quot;&gt;&lt;/a&gt;关于「Not enough memory」错误&lt;/h4&gt;&lt;p&gt;对于内存较低的可能出现启动时内存不够而导致失败的情况，因为docker默认是配置2G内存。&lt;br&gt;&lt;strong&gt;解决方式&lt;/strong&gt;：右键docker图标-setting-Advanced，如图：&lt;br&gt;&lt;img src=&quot;http://oaewlsdmg.bkt.clouddn.com/image/jpg/QQ%E6%88%AA%E5%9B%BE20160727153322.png&quot; alt=&quot;&quot;&gt;可以尝试不断减少Memory，直到启动OK，Docker正确启动后，左下角显示running。&lt;/p&gt;
&lt;h3 id=&quot;Demo演示&quot;&gt;&lt;a href=&quot;#Demo演示&quot; class=&quot;headerlink&quot; title=&quot;Demo演示&quot;&gt;&lt;/a&gt;Demo演示&lt;/h3&gt;&lt;p&gt;下面尝试run两个container，第一个是hello-world，第二个是webserver。在执行docker run containerName命令之后，Docker会先在本地检查对应是否存在该镜像，如果不存在再到Docker Hub上检查，如果有则立即下载到宿主机。&lt;/p&gt;
&lt;h4 id=&quot;hello-world&quot;&gt;&lt;a href=&quot;#hello-world&quot; class=&quot;headerlink&quot; title=&quot;hello-world&quot;&gt;&lt;/a&gt;hello-world&lt;/h4&gt;&lt;p&gt;在cmd或者PowerShell中输入：docker run hello-world，却不料出现Network timed out while trying to connect to…如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bash.exe&amp;quot;-3.1$ docker run hello-world&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Unable to find image &amp;apos;hello-world:latest&amp;apos; locally&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Pulling repository docker.io/library/hello-world&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c:\Program Files\Docker\Docker\Resources\bin\docker.exe: Network timed out while trying to connect to https://index.docker.io/v1/repositories/library/hello-world/images&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;. You may want to check your internet connection or if you are behind a proxy..&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方式&lt;/strong&gt;：通过Google从docker-machine restart default这条命令得到提示，如果直接执行该命令报错不成功，手动exit docker之后，重新start，再docker run hello-world，问题解决！&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bash.exe&amp;quot;-3.1$ docker run hello-world&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Unable to find image &amp;apos;hello-world:latest&amp;apos; locally&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;latest: Pulling from library/hello-world&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c04b14da8d14: Pull complete&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Digest: sha256:0256e8a36e2070f7bf2d0b0763dbabdd67798512411de4cdcf9431a1feb60fd9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Status: Downloaded newer image for hello-world:latest&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Hello from Docker!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;This message shows that your installation appears to be working correctly.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;To generate this message, Docker took the following steps:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 1. The Docker client contacted the Docker daemon.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 2. The Docker daemon pulled the &amp;quot;hello-world&amp;quot; image from the Docker Hub.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 3. The Docker daemon created a new container from that image which runs the&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    executable that produces the output you are currently reading.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 4. The Docker daemon streamed that output to the Docker client, which sent it&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    to your terminal.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;webserver-nginx&quot;&gt;&lt;a href=&quot;#webserver-nginx&quot; class=&quot;headerlink&quot; title=&quot;webserver nginx&quot;&gt;&lt;/a&gt;webserver nginx&lt;/h4&gt;&lt;p&gt;运行一个docker化的webserver，输入：docker run -d -p 80:80 –name webserver nginx，如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bash.exe&amp;quot;-3.1$ docker run -d -p 80:80 --name webserver nginx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Unable to find image &amp;apos;nginx:latest&amp;apos; locally&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;latest: Pulling from library/nginx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51f5c6a04d83: Pull complete&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a3ed95caeb02: Pull complete&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51d229e136d0: Pull complete&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bcd41daec8cc: Pull complete&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Digest: sha256:0fe6413f3e30fcc5920bc8fa769280975b10b1c26721de956e1428b9e2f29d04&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Status: Downloaded newer image for nginx:latest&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;592533495a5f766ce87c4460fe277460db9c5eed2469c87625a0d1ba2633dc43&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;继续执行：docker ps，可以看到各个容器的详情，不过目前只有一个nginx，如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                         NAMES&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;592533495a5f        nginx               &amp;quot;nginx -g &amp;apos;daemon off&amp;quot;   2 minutes ago       Up 2 minutes        0.0.0.0:80-&amp;gt;80/tcp, 443/tcp   webserver&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以看到nginx的IP和端口是：0.0.0.0:80，浏览器访问localhost（或者docker/），就会看到如下页面：&lt;br&gt;&lt;img src=&quot;http://oaewlsdmg.bkt.clouddn.com/image/jpg/QQ%E6%88%AA%E5%9B%BE20160727201002.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Hyper-V管理器&quot;&gt;&lt;a href=&quot;#Hyper-V管理器&quot; class=&quot;headerlink&quot; title=&quot;Hyper-V管理器&quot;&gt;&lt;/a&gt;Hyper-V管理器&lt;/h3&gt;&lt;p&gt;windows自带有Hyper-V管理器，进入「开始菜单-windows管理工具」，可以看到新建的 Hyper-V管理器，打开之后可以看到WIN-4FQM25FK460虚拟机，以及虚拟机中正在运行的MobyLinuxVM实例，如下：&lt;br&gt;&lt;img src=&quot;http://oaewlsdmg.bkt.clouddn.com/image/jpg/QQ%E6%88%AA%E5%9B%BE20160727190746.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/docker-for-windows/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Windows安装官方文档&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://forums.docker.com/t/docker-1-12-for-windows-10-is-not-working/16647/2&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;关于「Unable to write to the database. Exit 1」错误&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;-EOF-&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;第一次听到docker这个词是15年7月份，老板让项目组老大看看docker相关技术，据说是可以提高公司项目部署的效率，不过遗憾的是的当时已经准备快离职了，所以没能早一点一睹docker容器的庐山真面目。现在看来docker的热度也不是一年之前能比的了，不过也激发了我对技术的好奇心，决定挖这样一个坑，来激励自己去研究一下docker的内部原理和实际应用。本篇文章记录安装过程中出现的一些问题和解决过程，重点在于启动过程中的几个错误。&lt;br&gt;注：不同的系统和硬件环境下安装文件和过程不太一样，所以:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;采用Docker Toolbox方式安装的请绕行。&lt;/li&gt;
&lt;li&gt;以下适用于Docker for Windows Beta的安装，详情请看下面「安装-环境要求」。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Docker" scheme="https://zouzls.github.io/categories/Docker/"/>
    
    
      <category term="docker" scheme="https://zouzls.github.io/tags/docker/"/>
    
      <category term="windows10" scheme="https://zouzls.github.io/tags/windows10/"/>
    
      <category term="安装" scheme="https://zouzls.github.io/tags/%E5%AE%89%E8%A3%85/"/>
    
      <category term="启动" scheme="https://zouzls.github.io/tags/%E5%90%AF%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat源码分析之Connector初始化与启动</title>
    <link href="https://zouzls.github.io/2016/07/20/Tomcat%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BConnector%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%90%AF%E5%8A%A8/"/>
    <id>https://zouzls.github.io/2016/07/20/Tomcat源码分析之Connector初始化与启动/</id>
    <published>2016-07-20T08:06:35.000Z</published>
    <updated>2016-08-26T10:48:17.551Z</updated>
    
    <content type="html">&lt;p&gt;Tomcat主要由两大核心组件，一个是connector,一个是container。connector负责的是底层的网络通信的实现，而container负责的是上层servlet业务的实现。一个应用服务器的性能很大程度上取决于网络通信模块的实现，因此connector对于tomcat而言是重中之重。源码看到Connector的时候，确实看的比较费劲，里面错综复杂的类结构和继承关系，确实头昏脑涨，下面我尝试用清晰一点的脉络去理解Connector。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Connector配置&quot;&gt;&lt;a href=&quot;#Connector配置&quot; class=&quot;headerlink&quot; title=&quot;Connector配置&quot;&gt;&lt;/a&gt;Connector配置&lt;/h3&gt;&lt;p&gt;在{源码根目录}/conf路径下的server.xml文件中，service内部可以看到Connector的配置：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;Connector port=&amp;quot;8080&amp;quot; protocol=&amp;quot;HTTP/1.1&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           connectionTimeout=&amp;quot;20000&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           redirectPort=&amp;quot;8443&amp;quot; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;Connector port=&amp;quot;8009&amp;quot; protocol=&amp;quot;AJP/1.3&amp;quot; redirectPort=&amp;quot;8443&amp;quot; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;尤其是HTTP/1.1协议的配置，后面在Connector初始化的过程中，我们可以看到它的作用（下面的讨论都是基于HTTP/1.1之上，不再说明）。&lt;/p&gt;
&lt;h3 id=&quot;主要类和接口&quot;&gt;&lt;a href=&quot;#主要类和接口&quot; class=&quot;headerlink&quot; title=&quot;主要类和接口&quot;&gt;&lt;/a&gt;主要类和接口&lt;/h3&gt;&lt;p&gt;下面类会比较常见，而且关系比较错综复杂，提前心中有数比较好，如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Http11Protocol&lt;br&gt;1、继承关系：Http11Protocol - AbstractProtocol - ProtocolHandler。&lt;br&gt;2、Http11Protocol是ProtocolHandler的的最终实现，并且Connector对于请求的真正的处理是由Http11Protocol这个boss搞定的，这个boss负责有三个重要的实例，分别是JIoEndpoint、Http11ConnectionHandler和CoyoteAdapter，他们各司其职。如图：&lt;br&gt;&lt;img src=&quot;http://oaewlsdmg.bkt.clouddn.com/image/jpg/1358483637_2091.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;JIoEndpoint&lt;br&gt;1、继承关系：JIoEndpoint - AbstractEndpoint&lt;socket&gt;。&lt;br&gt;2、在Http11Protocol的构造函数中被初始化。&lt;br&gt;3、完成端口的绑定，对请求进行监听，并将获取的socket交给Http11ConnectionHandler来process。&lt;/socket&gt;&lt;/li&gt;
&lt;li&gt;Http11ConnectionHandler&lt;br&gt;1、继承关系：Http11ConnectionHandler - AbstractConnectionHandler -  Handler。&lt;br&gt;2、在Http11Protocol的构造函数中被初始化，并被设置为JIoEndpoint的cHandler。&lt;br&gt;3、作为Http11Protocol的内部类，处理socket任务。&lt;/li&gt;
&lt;li&gt;CoyoteAdapter&lt;br&gt;1、继承关系：CoyoteAdapter - Adapter&lt;br&gt;2、在Connector的init方法中被初始化，并被设置为protocolHandler的adapter。&lt;br&gt;3、作为Connector和Container之间的桥梁，可以理解为有两个作用，一个是将Connector的请求交给Container，同时隔离了两边请求；二个是可以作为拓展。&lt;br&gt;&lt;img src=&quot;http://oaewlsdmg.bkt.clouddn.com/blog%2Fimage%2F20150426172846043.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;【注】：JIoEndpoint和Http11ConnectionHandler是在Http11Protocol的构造函数中被初始化，代码如下：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Http11Protocol&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    endpoint = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; JIoEndpoint();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cHandler = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Http11ConnectionHandler(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ((JIoEndpoint) endpoint).setHandler(cHandler);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setSoLinger(Constants.DEFAULT_CONNECTION_LINGER);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setSoTimeout(Constants.DEFAULT_CONNECTION_TIMEOUT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setTcpNoDelay(Constants.DEFAULT_TCP_NO_DELAY);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;JIoEndpoint设置了Handler为Http11ConnectionHandler，至于后面怎么用，会继续分析。下面分析Connector是如何初始化和启动的。&lt;/p&gt;
&lt;h3 id=&quot;Connector初始化&quot;&gt;&lt;a href=&quot;#Connector初始化&quot; class=&quot;headerlink&quot; title=&quot;Connector初始化&quot;&gt;&lt;/a&gt;Connector初始化&lt;/h3&gt;&lt;h4 id=&quot;Connector的构造函数&quot;&gt;&lt;a href=&quot;#Connector的构造函数&quot; class=&quot;headerlink&quot; title=&quot;Connector的构造函数&quot;&gt;&lt;/a&gt;Connector的构造函数&lt;/h4&gt;&lt;p&gt;构造函数里面主要是搞定Http11Protocol这个超级Handler的实例化，Connector的通信的实际任务就是由该对象一手策划完成，代码如下：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; String protocolHandlerClassName =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;org.apache.coyote.http11.Http11Protocol&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Connector&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String protocol)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//step1 设置协议变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setProtocol(protocol);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Instantiate protocol handler&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//step2 根据协议动态加载协议类和实例化该对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Class&amp;lt;?&amp;gt; clazz = Class.forName(protocolHandlerClassName);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.protocolHandler = (ProtocolHandler) clazz.newInstance();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        log.error(sm.getString(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;string&quot;&gt;&quot;coyoteConnector.protocolHandlerInstantiationFailed&quot;&lt;/span&gt;), e);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//setProtocol方法来确定class名称&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setProtocol&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String protocol)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&quot;HTTP/1.1&quot;&lt;/span&gt;.equals(protocol)) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//配置文件中已经配置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        setProtocolHandlerClassName&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            (&lt;span class=&quot;string&quot;&gt;&quot;org.apache.coyote.http11.Http11Protocol&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;Connector的initInternal方法&quot;&gt;&lt;a href=&quot;#Connector的initInternal方法&quot; class=&quot;headerlink&quot; title=&quot;Connector的initInternal方法&quot;&gt;&lt;/a&gt;Connector的initInternal方法&lt;/h4&gt;&lt;p&gt;Connector的initInternal()初始化方法被调用主要是设置当前Connector的适配器并且完成Http11Protocol的初始化，如下：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;initInternal&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; LifecycleException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//step1 初始化一个适配器（Connector和Container的桥梁）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    adapter = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; CoyoteAdapter(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//并将adapter设置Handler的适配器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    protocolHandler.setAdapter(adapter);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//step2 协议初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        protocolHandler.init();&lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LifecycleException&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            (sm.getString&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             (&lt;span class=&quot;string&quot;&gt;&quot;coyoteConnector.protocolHandlerInitializationFailed&quot;&lt;/span&gt;), e);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//step3 Initialize mapper listener&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mapperListener.init();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;【注】：这里先对CoyoteAdapter做一个简单的解释，Connector监听到底层的请求之后，&lt;br&gt;会中间经过一系列准备工作之后，创建org.apache.coyote.Request和org.apache.coyote.Response（注意Request和Response所属的范围），交给CoyoteAdapter的service(org.apache.coyote.Request req,org.apache.coyote.Response res)方法，在这个方法内部会进行适配，也可以理解为转换，变成org.apache.catalina.connector.Request和org.apache.catalina.connector.Response，然后交给Container处理，service方法的代码可以简单了解如下(部分省略)：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;service&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(org.apache.coyote.Request req,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    org.apache.coyote.Response res)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Request request = (Request) req.getNote(ADAPTER_NOTES);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Response response = (Response) res.getNote(ADAPTER_NOTES);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (request == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Create objects&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        request = connector.createRequest();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        request.setCoyoteRequest(req);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        response = connector.createResponse();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        response.setCoyoteResponse(res);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Calling the container&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);&lt;span class=&quot;comment&quot;&gt;//请求最终交给Container&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;JIoEndpoint的init方法&quot;&gt;&lt;a href=&quot;#JIoEndpoint的init方法&quot; class=&quot;headerlink&quot; title=&quot;JIoEndpoint的init方法&quot;&gt;&lt;/a&gt;JIoEndpoint的init方法&lt;/h4&gt;&lt;p&gt;protocolHandler.init()方法会调用Http11Protocol祖父类（AbstractProtocol）的init方法，然后接着调用JIoEndpoint抽象父类（AbstractEndpoint）的init，最终是由IoEndpoint的band方法完成端口的绑定。我们可以看到AbstractEndpoint的init()方法，如下：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//定义了抽象的绑定操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    testServerCipherSuitesOrderSupport();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (bindOnInit) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        bind();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        bindState = BindState.BOUND_ON_INIT;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果在eclipse中打开bind()方法会看到三个不同类的实现，毫无疑问应该是第二个实现JIoEndpoint，如下图：&lt;br&gt;&lt;img src=&quot;http://oaewlsdmg.bkt.clouddn.com/image/jpg/QQ%E5%9B%BE%E7%89%8720160721100955.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;在这个过程中我们可以知道设计者的心思，设计者在AbstractProtocol和AbstractEndpoint中分别将各种共用的关键的方法和变量进行了定义，这样体现了抽象类的作用。&lt;br&gt;在JIoEndpoint中bind方法代码实现如下：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Initialize thread count defaults for acceptor&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (acceptorThreadCount == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        acceptorThreadCount = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Initialize maxConnections&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (getMaxConnections() == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// User hasn&#39;t set a value - use the default&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        setMaxConnections(getMaxThreadsExecutor(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    serverSocketFactory =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                handler.getSslImplementation().getServerSocketFactory(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    serverSocket = serverSocketFactory.createSocket(getPort(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        getBacklog());  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;Connector启动&quot;&gt;&lt;a href=&quot;#Connector启动&quot; class=&quot;headerlink&quot; title=&quot;Connector启动&quot;&gt;&lt;/a&gt;Connector启动&lt;/h3&gt;&lt;h4 id=&quot;Connector的startInternal方法&quot;&gt;&lt;a href=&quot;#Connector的startInternal方法&quot; class=&quot;headerlink&quot; title=&quot;Connector的startInternal方法&quot;&gt;&lt;/a&gt;Connector的startInternal方法&lt;/h4&gt;&lt;p&gt;这个过程跟Connector的初始化过程前半部分相似，代码实现如下：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;startInternal&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; LifecycleException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        protocolHandler.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mapperListener.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;毫无疑问是调用protocolHandler的start方法，由Http11Protocol的祖父类AbstractProtocol的start方法，代码如下：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        endpoint.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Exception ex) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ....&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;父类抽象的实现了start方法，接下来调用endpoint.start()，目前为止与上文中的endpoint.init()方法如出一辙，如下AbstractEndpoint中的start方法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public final void start() throws Exception &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (bindState == BindState.UNBOUND) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        bind();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        bindState = BindState.BOUND_ON_START;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    startInternal();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;JIoEndpoint中的startInternal方法&quot;&gt;&lt;a href=&quot;#JIoEndpoint中的startInternal方法&quot; class=&quot;headerlink&quot; title=&quot;JIoEndpoint中的startInternal方法&quot;&gt;&lt;/a&gt;JIoEndpoint中的startInternal方法&lt;/h4&gt;&lt;p&gt;同样startInternal()也有三个实现，进入JIoEndpoint中，则有：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;startInternal&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!running) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        running = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        paused = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Create worker collection&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (getExecutor() == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            createExecutor();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        initializeConnectionLatch();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        startAcceptorThreads();&lt;span class=&quot;comment&quot;&gt;//这个就是重头戏啦&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Start async timeout thread&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Thread timeoutThread = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; AsyncTimeout(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                getName() + &lt;span class=&quot;string&quot;&gt;&quot;-AsyncTimeout&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        timeoutThread.setPriority(threadPriority);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        timeoutThread.setDaemon(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        timeoutThread.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;JIoEndpoint的startAcceptorThreads方法&quot;&gt;&lt;a href=&quot;#JIoEndpoint的startAcceptorThreads方法&quot; class=&quot;headerlink&quot; title=&quot;JIoEndpoint的startAcceptorThreads方法&quot;&gt;&lt;/a&gt;JIoEndpoint的startAcceptorThreads方法&lt;/h4&gt;&lt;p&gt;中间的startAcceptorThreads()就是开启接受请求线程咯，我们进去一睹庐山真面看看，进去之后会进入AbstractEndpoint中，又来到这个类了，代码如下：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;startAcceptorThreads&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; count = getAcceptorThreadCount();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    acceptors = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Acceptor[count];&lt;span class=&quot;comment&quot;&gt;//此处的Acceptor是个接口&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; count; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        acceptors[i] = createAcceptor();&lt;span class=&quot;comment&quot;&gt;//此处根据协议不同创建不同的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String threadName = getName() + &lt;span class=&quot;string&quot;&gt;&quot;-Acceptor-&quot;&lt;/span&gt; + i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        acceptors[i].setThreadName(threadName);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Thread t = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread(acceptors[i], threadName);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        t.setPriority(getAcceptorThreadPriority());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        t.setDaemon(getDaemon());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        t.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; Acceptor &lt;span class=&quot;title&quot;&gt;createAcceptor&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//AbstractEndpoint已经定义好了这个抽象方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;new Acceptor[count]中的Acceptor其实就是AbstractEndpoint的一个抽象的内部类，看看它大概是什么样的吧：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Acceptor&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Runnable&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ....&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;一看就是个线程对不对，但是只是定义了一些变量，没有定义run() 方法，所以我们要看createAcceptor()中是如何实现的，进入由JIoEndpoint中，如下：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; AbstractEndpoint.&lt;span class=&quot;function&quot;&gt;Acceptor &lt;span class=&quot;title&quot;&gt;createAcceptor&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Acceptor();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;尼玛搞了半天，以为快水落石出了，结果你只是又扔出来一个Acceptor，好吧看看那么这个有何不同，进去看看：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Acceptor&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AbstractEndpoint&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Acceptor&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Loop until we receive a shutdown command&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (running) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Socket socket = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                socket = serverSocketFactory.acceptSocket(serverSocket);&lt;span class=&quot;comment&quot;&gt;//获取连接&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Configure the socket&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (running &amp;amp;&amp;amp; !paused &amp;amp;&amp;amp; setSocketOptions(socket)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;// Hand this socket off to an appropriate processor&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!processSocket(socket)) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//关键处理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;从processSocket(socket)中进去看到socket被包装了起来，交给了SocketProcessor，该类是JIoEndpoint的内部类，作为专门处理socket的线程。&lt;/p&gt;
&lt;h4 id=&quot;Http11ConnectionHandler的process方法&quot;&gt;&lt;a href=&quot;#Http11ConnectionHandler的process方法&quot; class=&quot;headerlink&quot; title=&quot;Http11ConnectionHandler的process方法&quot;&gt;&lt;/a&gt;Http11ConnectionHandler的process方法&lt;/h4&gt;&lt;p&gt;接下来就可以看到真正处理socket的东西了，最前面前面我们提到过，JIoEndpoint和Http11ConnectionHandler是在Http11Protocol的构造函数中被初始化，JIoEndpoint同时设置了Http11ConnectionHandler作为Handler。所以，回头来看，我们知道JIoEndpoint在接收到socket请求之后，实际是经过一定的准备工作，然后将socket交给了Http11ConnectionHandler这个去处理了。代码如下：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Handling of accepted sockets.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; Handler handler = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setHandler&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Handler handler )&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.handler = handler; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SocketProcessor&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Runnable&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((state != SocketState.CLOSED)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (status == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                state = handler.process(socket, SocketStatus.OPEN_READ);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                state = handler.process(socket,status);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;由源码可知，通过Http11ConnectionHandler的父类AbstractConnectionHandler定义的process方法（设计者可能是为了方便拓展），然后又用Http11Processor的父类的AbstractHttp11Processor的process方法，才调用了埋伏已久的adapter.service(req,resp)方法，等这一刻等的有点久了。代码如下：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; SocketState &lt;span class=&quot;title&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(SocketWrapper&amp;lt;S&amp;gt; socketWrapper)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       adapter.service(request, response);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;至此，Connector的初始化和启动分析的差不多了，并将这个过程中创建的Request和Response交给了adapter这个桥梁，至于service方法内部做了哪些工作，在前面有分析，如果看到这儿，再回头看看文章开始的那几个类，大概整个流程差不多了然于胸了。&lt;/p&gt;
&lt;h3 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://wely.iteye.com/blog/2295171&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;tomcat源码分析-Connector初始化与启动&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/liweisnake/article/details/8513295&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;tomcat6中的请求流程 - CSDN.NET&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.it610.com/article/2301453.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;tomcat connector学习笔记 &lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/wangyangzhizhou/article/details/45290061&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;连接器与容器的桥梁——CoyoteAdapter&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;-EOF-&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Tomcat主要由两大核心组件，一个是connector,一个是container。connector负责的是底层的网络通信的实现，而container负责的是上层servlet业务的实现。一个应用服务器的性能很大程度上取决于网络通信模块的实现，因此connector对于tomcat而言是重中之重。源码看到Connector的时候，确实看的比较费劲，里面错综复杂的类结构和继承关系，确实头昏脑涨，下面我尝试用清晰一点的脉络去理解Connector。&lt;br&gt;
    
    </summary>
    
      <category term="Tomcat" scheme="https://zouzls.github.io/categories/Tomcat/"/>
    
    
      <category term="Tomcat" scheme="https://zouzls.github.io/tags/Tomcat/"/>
    
      <category term="源码分析" scheme="https://zouzls.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="环境搭建" scheme="https://zouzls.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat源码分析之生命周期管理</title>
    <link href="https://zouzls.github.io/2016/07/05/Tomcat%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/"/>
    <id>https://zouzls.github.io/2016/07/05/Tomcat源码分析之生命周期管理/</id>
    <published>2016-07-05T11:33:47.000Z</published>
    <updated>2016-08-26T10:48:39.742Z</updated>
    
    <content type="html">&lt;p&gt;Tomcat源码调试环境搭好了，但是打开源码却是一头雾水，不知从哪下手，我觉得这是阅读任何项目源码刚开始都会遇到的问题，但是问题从来不可怕，下面我在Tomcat源码分析中的一些理解吧。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;概念理解&quot;&gt;&lt;a href=&quot;#概念理解&quot; class=&quot;headerlink&quot; title=&quot;概念理解&quot;&gt;&lt;/a&gt;概念理解&lt;/h3&gt;&lt;p&gt;谈一下对「容器」、「生命周期」、「观察者模式」这个三个概念的理解，这几个是介绍Tomcat源码和系统架构的书籍和文章中常见的概念，也是理解Tomcat设计的精髓。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器&lt;br&gt;打开源码“/conf”目录下的server.xml文件，可以看到最顶层到里面依次有server、service、connector等等，这些解析之后便成为Tomcat的容器。我们姑且可以理解为管理子容器或者内部一些未知东西的工具。&lt;/li&gt;
&lt;li&gt;生命周期&lt;br&gt;容器有初始化（init）、开始（start）和停止（stop）等各种状态，如何去管理一个容器从开始到结束，这应该就是生命周期管理吧，先这么简单的理解吧，认识都是一个过程，暂时也没法理解的那么全面。&lt;/li&gt;
&lt;li&gt;观察者模式&lt;br&gt;不太理解的可以专门看看这个设计模式。这里可以简单理解为，把容器当做一个主题（subject），还有若干监听者（listener），容器状态的改变会触发监听者listener的一些动作等等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;关键类和接口&quot;&gt;&lt;a href=&quot;#关键类和接口&quot; class=&quot;headerlink&quot; title=&quot;关键类和接口&quot;&gt;&lt;/a&gt;关键类和接口&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Bootstrap&lt;br&gt;Tomcat源码工程巨大，但是总有一个入口，我们在启动Tomcat工程的时候，会发现项目是从Bootstrap类开始（org.apache.catalina.startup.Bootstrap.java）,main方法就在这里了，到此至少知道项目是从何处开始的了。&lt;/li&gt;
&lt;li&gt;StandardServer&lt;br&gt;该类是对Server的具体实现，Tomcat的生命周期就是由Server掌控，Server由此是Tomcat最高级的组件，没有之一，Tomcat启动之后，首先便是Server的启动。至于Server下面的service容器暂时先不管，知道了一种容器的生命周期，其他的也就类似了。&lt;/li&gt;
&lt;li&gt;LifecycleBase&lt;br&gt;该类是对Lifecycle接口的实现，所有的容器都是要继承该类的，StandardServer的继承关系是：StandardServer-LifecycleMBeanBase-LifecycleBase。&lt;/li&gt;
&lt;li&gt;LifecycleSupport&lt;br&gt;是LifecycleBase的一个支持辅助类吧，随着容器的新建会初始化new一个，容器状态如果改变，会帮忙搞定事件触发的操作。&lt;/li&gt;
&lt;li&gt;LifecycleListener&lt;br&gt;上面的三个类主要跟容器有关，而这是一个监听者接口，看下面源码中的注释就可以知道了这个接口的作用的，下面是完整接口：&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Interface defining a listener for significant events (including &quot;component&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * start&quot; and &quot;component stop&quot; generated by a component that implements the&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Lifecycle interface. The listener will be fired after the associated state&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * change has taken place.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@author&lt;/span&gt; Craig R. McClanahan&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;LifecycleListener&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * Acknowledge the occurrence of the specified event.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; event LifecycleEvent that has occurred&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;lifecycleEvent&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(LifecycleEvent event)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;翻译一下：接口定义了一个对一些重要events感兴趣的listener，主要是那些由实现了Lifecycle接口的组件所产生的包括“start”和“stop”的events事件，这个监听者会被关联的状态触发。&lt;/p&gt;
&lt;h3 id=&quot;生命周期管理及观察流程&quot;&gt;&lt;a href=&quot;#生命周期管理及观察流程&quot; class=&quot;headerlink&quot; title=&quot;生命周期管理及观察流程&quot;&gt;&lt;/a&gt;生命周期管理及观察流程&lt;/h3&gt;&lt;h4 id=&quot;StandardServer的startInternal-开始&quot;&gt;&lt;a href=&quot;#StandardServer的startInternal-开始&quot; class=&quot;headerlink&quot; title=&quot;StandardServer的startInternal()开始&quot;&gt;&lt;/a&gt;StandardServer的startInternal()开始&lt;/h4&gt;&lt;p&gt;StandardServer父类LifecycleBase中的start()方法被调用之后，紧接着StandardServer的startInternal()调用，下面是startInternal()的具体实现：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;startInternal&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; LifecycleException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fireLifecycleEvent(CONFIGURE_START_EVENT, &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//容器启动，触发事件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setState(LifecycleState.STARTING);&lt;span class=&quot;comment&quot;&gt;//设置容器的状态为STARTING&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    globalNamingResources.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Start our defined Services&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; (servicesLock) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; services.length; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            services[i].start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;LifecycleBase的fireLifecycleEvent-方法代理&quot;&gt;&lt;a href=&quot;#LifecycleBase的fireLifecycleEvent-方法代理&quot; class=&quot;headerlink&quot; title=&quot;LifecycleBase的fireLifecycleEvent()方法代理&quot;&gt;&lt;/a&gt;LifecycleBase的fireLifecycleEvent()方法代理&lt;/h4&gt;&lt;p&gt;因为我自己状态改变了下，我要把消息告诉那些监听者，StandardServer调用了父类LifecycleBase的fireLifecycleEvent()，该方法代码如下：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; type  Event type&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; data  Data associated with event.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;fireLifecycleEvent&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String type, Object data)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    lifecycle.fireLifecycleEvent(type, data);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;lifecycle是这么被定义的：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Used to handle firing lifecycle events.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;TODO:&lt;/span&gt; Consider merging LifecycleSupport into this class.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; LifecycleSupport lifecycle = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LifecycleSupport(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;思考弄一下这里的this参数是什么，说白了LifecycleSupport就是专门定义一个帮忙干活的，this就是当前的容器实例。&lt;/p&gt;
&lt;h4 id=&quot;LifecycleSupport的fireLifecycleEvent-方法被触发&quot;&gt;&lt;a href=&quot;#LifecycleSupport的fireLifecycleEvent-方法被触发&quot; class=&quot;headerlink&quot; title=&quot;LifecycleSupport的fireLifecycleEvent()方法被触发&quot;&gt;&lt;/a&gt;LifecycleSupport的fireLifecycleEvent()方法被触发&lt;/h4&gt;&lt;p&gt;直接上代码吧：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Notify all lifecycle event listeners that a particular event has&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * occurred for this Container.  The default implementation performs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * this notification synchronously using the calling thread.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; type Event type&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; data Event data&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;fireLifecycleEvent&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String type, Object data)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LifecycleEvent event = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LifecycleEvent(lifecycle, type, data);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LifecycleListener interested[] = listeners;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; interested.length; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        interested[i].lifecycleEvent(event);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;问题已经快水落石出了，LifecycleSupport似乎是维护了listener的一个数据结构，数组，如下代码所示：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * The set of registered LifecycleListeners for event notifications.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; LifecycleListener listeners[] = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LifecycleListener[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;LifecycleSupport专门负责管理一些监听者（listener）的事情，比如：addLifecycleListener()、removeLifecycleListener()等等，跟listeners打交道的脏活累活最后都落到LifecycleSupport身上了。&lt;/p&gt;
&lt;h4 id=&quot;LifecycleListener的lifecycleEvent-方法被触发&quot;&gt;&lt;a href=&quot;#LifecycleListener的lifecycleEvent-方法被触发&quot; class=&quot;headerlink&quot; title=&quot;LifecycleListener的lifecycleEvent()方法被触发&quot;&gt;&lt;/a&gt;LifecycleListener的lifecycleEvent()方法被触发&lt;/h4&gt;&lt;p&gt;因为LifecycleListener只是一个接口，所以举一个实现类为例，如NamingContextListener类，为什么拿这个举例后面就知道了，下面就是NamingContextListener的lifecycleEvent(LifecycleEvent event)方法：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Acknowledge the occurrence of the specified event.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; event LifecycleEvent that has occurred&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;lifecycleEvent&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(LifecycleEvent event)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ....&lt;span class=&quot;comment&quot;&gt;//略&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (Lifecycle.CONFIGURE_START_EVENT.equals(event.getType())) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ....&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (Lifecycle.CONFIGURE_STOP_EVENT.equals(event.getType())) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!initialized)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            objectNames.clear();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            namingContext = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            envCtx = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            compCtx = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            initialized = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;代码太长不贴那么多了，但是窥一斑可知，这里面做了很多事情，根据事件不同给出不同的处理。那么这个监听器是什么时候加入监听数组的呢？&lt;/p&gt;
&lt;h4 id=&quot;LifecycleListener的加入&quot;&gt;&lt;a href=&quot;#LifecycleListener的加入&quot; class=&quot;headerlink&quot; title=&quot;LifecycleListener的加入&quot;&gt;&lt;/a&gt;LifecycleListener的加入&lt;/h4&gt;&lt;p&gt;因为我们一开始就只讨论Server这个容器，那么回到刚开始的Server的实现类StandardServer这个类，观察构造方法会发现：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Construct a default instance of this class.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;StandardServer&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    globalNamingResources = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NamingResources();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    globalNamingResources.setContainer(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (isUseNaming()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        namingContextListener = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NamingContextListener();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        addLifecycleListener(namingContextListener);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;NamingContextListener这个listener是在容器创建之初就被放入了监听者行列，addLifecycleListener方法便是调用LifecycleBase的addLifecycleListener()这个代理方法，然后真正的脏活累活还是交给了前面交代的LifecycleSupport这个类来办。&lt;/p&gt;
&lt;h3 id=&quot;最后&quot;&gt;&lt;a href=&quot;#最后&quot; class=&quot;headerlink&quot; title=&quot;最后&quot;&gt;&lt;/a&gt;最后&lt;/h3&gt;&lt;p&gt;容器的生命周期和观察者模式大概就是这么回事了，后面还有一些问题需要继续思考，比如Server下面的Service到底是什么东西，Service里面的connector和container又是什么鬼，再慢慢分析吧。&lt;/p&gt;
&lt;p&gt;-EOF-&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Tomcat源码调试环境搭好了，但是打开源码却是一头雾水，不知从哪下手，我觉得这是阅读任何项目源码刚开始都会遇到的问题，但是问题从来不可怕，下面我在Tomcat源码分析中的一些理解吧。&lt;br&gt;
    
    </summary>
    
      <category term="Tomcat" scheme="https://zouzls.github.io/categories/Tomcat/"/>
    
    
      <category term="Tomcat" scheme="https://zouzls.github.io/tags/Tomcat/"/>
    
      <category term="源码分析" scheme="https://zouzls.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="生命周期管理" scheme="https://zouzls.github.io/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat源码分析之环境搭建</title>
    <link href="https://zouzls.github.io/2016/07/04/Tomcat%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://zouzls.github.io/2016/07/04/Tomcat源码分析之环境搭建/</id>
    <published>2016-07-04T11:33:47.000Z</published>
    <updated>2016-08-26T10:48:22.539Z</updated>
    
    <content type="html">&lt;h3 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h3&gt;&lt;p&gt;1、Tomcat7源码（官网下载即可）&lt;br&gt;2、jdk6环境（Tomcat7要求的编译环境是jdk6，所以如果之前安装jdk7的不用卸载，直接在安装一个jdk6就好了，修改一下JAVA_HOME即可。安装完之后记得检查java -version，如果还是java7版本，把c:\windows\system32目录下的javaw.exe、java.exe和javaws.exe三个文件删除就可以了。）&lt;br&gt;3、Ant 1.8.2 或者更高版本的构建工具。（直接官网下载解压，然后添加ANT_HOME,再在path中添加%ANT_HOME%\bin;，同样记得检查ant -version。）&lt;br&gt;4、eclipse工具&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Ant-构建&quot;&gt;&lt;a href=&quot;#Ant-构建&quot; class=&quot;headerlink&quot; title=&quot;Ant 构建&quot;&gt;&lt;/a&gt;Ant 构建&lt;/h3&gt;&lt;p&gt;cmd进入Tomcat source根目录。将build.properties.default文件重命名为build.properties，打开该文件找到base.path一项，可以修改value值，该路径下会下载tomcat依赖的包，可以自定义。然后在根目录，执行以下命令：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ant -p&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;（如果出现找不到ant的命令，可能是权限不够，用管理员身份打开cmd。）&lt;br&gt;会出现一系列可能的选项，中间有一项ide-eclipse，说明可以将项目变成eclipse的项目。此时源码目录还没有.settings文件夹、.classpath和.project两个文件。接下来执行：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ant ide-eclipse&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;中间可能会遇到超时连接的问题，如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;F:\tomcat-7.0-src\build.xml:2848: java.net.ConnectException: Connection timed out: connect&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        at java.net.PlainSocketImpl.socketConnect(Native Method)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        at java.net.PlainSocketImpl.doConnect(PlainSocketImpl.java:351)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        at java.net.PlainSocketImpl.connectToAddress(PlainSocketImpl.java:213)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        at java.net.PlainSocketImpl.connect(PlainSocketImpl.java:200)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:366)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        at java.net.Socket.connect(Socket.java:529)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        at com.sun.net.ssl.internal.ssl.SSLSocketImpl.connect(SSLSocketImpl.java:570)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;仔细向上查找问题，大概会发现有这么一行：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;testexist:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     [echo] Testing  for C:\Users\恭帅/tomcat-build-libs/objenesis-1.2/objenesis-1.2.jar&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;downloadzip:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      [get] Getting: https://objenesis.googlecode.com/files/objenesis-1.2-bin.zip&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      [get] To: C:\Users\$&amp;#123;个人电脑的用户名&amp;#125;\tomcat-build-libs\download-471197819.zip&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      [get] Error getting https://objenesis.googlecode.com/files/objenesis-1.2-bin.zip to C:\Users\$&amp;#123;个人电脑的用户名&amp;#125;\tomcat-build-libs\download-471197819.zip&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;到这就知道为什么会出现超时连接了，解决办法：直接到网上下载objenesis-1.2.jar，不一定去googlecode.com，然后到“C:\Users\${个人电脑的用户名}\tomcat-build-libs\”文件夹下，新建objenesis-1.2文件夹，将objenesis-1.2.jar放在该文件夹下，重新执行：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ant ide-eclipse&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;出现BUILD SUCCESSFUL就好了，然后查看源码根目录会发现.settings文件夹、.classpath和.project两个文件，接下来是导入eclipse工具中了。&lt;/p&gt;
&lt;h3 id=&quot;导入eclipse&quot;&gt;&lt;a href=&quot;#导入eclipse&quot; class=&quot;headerlink&quot; title=&quot;导入eclipse&quot;&gt;&lt;/a&gt;导入eclipse&lt;/h3&gt;&lt;p&gt;1、打开eclipse可能会报错，因为我们删除过c:\windows\system32目录下面的三个文件，所以解决办法是，将path中的JAVA_HOME移到path最前面，就可以解决这个问题。&lt;br&gt;2、按照一般流程import&amp;gt;existing projects into workplace，就行了。&lt;br&gt;导入之后，会发现项目左上角出现红色的感叹号的问题，访问&lt;a href=&quot;http://my.oschina.net/u/2457218/blog/657410&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇文章&lt;/a&gt;，文末有详细的解决方案，在此不赘述了。&lt;/p&gt;
&lt;h3 id=&quot;运行Tomcat&quot;&gt;&lt;a href=&quot;#运行Tomcat&quot; class=&quot;headerlink&quot; title=&quot;运行Tomcat&quot;&gt;&lt;/a&gt;运行Tomcat&lt;/h3&gt;&lt;p&gt;右键项目，Debug-Java Application-Bootstrap-start tomcat就行了。&lt;br&gt;———————-更新—————————&lt;br&gt;第二次我在自己电脑上重新搭建了一下发现按照上述流程，导入eclipse之后一直启动不了，总是报下列错误：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...,Server instance is not configured.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我仔细看了output/build下面的文件夹，发现bin、conf、lib、log、webapps这些文件夹全部为空，Google了一下原因，项目通过&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ant ide-eclipse&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个命令只是构建成了eclipse项目，但是没有编译，所以启动不成功，所以解决问题的办法就是在上述命令执行完之后，继续执行下条命令：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ant&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;-EOF-&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h3&gt;&lt;p&gt;1、Tomcat7源码（官网下载即可）&lt;br&gt;2、jdk6环境（Tomcat7要求的编译环境是jdk6，所以如果之前安装jdk7的不用卸载，直接在安装一个jdk6就好了，修改一下JAVA_HOME即可。安装完之后记得检查java -version，如果还是java7版本，把c:\windows\system32目录下的javaw.exe、java.exe和javaws.exe三个文件删除就可以了。）&lt;br&gt;3、Ant 1.8.2 或者更高版本的构建工具。（直接官网下载解压，然后添加ANT_HOME,再在path中添加%ANT_HOME%\bin;，同样记得检查ant -version。）&lt;br&gt;4、eclipse工具&lt;br&gt;
    
    </summary>
    
      <category term="Tomcat" scheme="https://zouzls.github.io/categories/Tomcat/"/>
    
    
      <category term="Tomcat" scheme="https://zouzls.github.io/tags/Tomcat/"/>
    
      <category term="源码分析" scheme="https://zouzls.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="环境搭建" scheme="https://zouzls.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>与表哥对话录</title>
    <link href="https://zouzls.github.io/2016/06/26/%E4%B8%8E%E8%A1%A8%E5%93%A5%E5%AF%B9%E8%AF%9D%E5%BD%95/"/>
    <id>https://zouzls.github.io/2016/06/26/与表哥对话录/</id>
    <published>2016-06-26T12:56:47.000Z</published>
    <updated>2016-08-26T10:47:17.292Z</updated>
    
    <content type="html">&lt;p&gt;古人说得好，问渠那得清如许，为有源头活水来。生活中最有趣的事情之一，便是有不断「活水」注入了，这里的活水可以是人，事，也可以是思想和交流。尤其是那些可以给你在学习或者某个领域带来启发性思考的人，今晚便有了这样一次机会。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;我叫他伟伟哥，他在某种程度算是我表哥，另外一种身份也是我的师兄，武大博士毕业，现任职华为中央软件研究院，Team Leader，哈哈。表哥给人感觉低调内敛，其貌不扬，衣着朴素到你绝对想不到他会是面试过众多清华北大华科中科大等一干名校包括美帝学校博士生的面试官。&lt;br&gt;我们的聊天在吃饭的时候展开，短短一个多小时的时间，表哥在谈到自己的经历和对某些热门技术的看法所表现的深度和和独特带给我的启发还是不少的，记之成文，日后翻阅也许有用。&lt;/p&gt;
&lt;h4 id=&quot;关于热门技术的思考&quot;&gt;&lt;a href=&quot;#关于热门技术的思考&quot; class=&quot;headerlink&quot; title=&quot;关于热门技术的思考&quot;&gt;&lt;/a&gt;关于热门技术的思考&lt;/h4&gt;&lt;p&gt;表哥对于热门技术的思考，以及他们之间的关系的理解，还是让我有一种如沐春风的感觉。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;他说「云」是平台级别的技术解决方案，对内核心技术在于虚拟化技术，对外云有资源共享的思想体现，然后提到一些行业解决方案和开源产品，如：docker、openStack等等。&lt;/li&gt;
&lt;li&gt;云平台之上就是更加热门的「大数据」领域了，大数据本质上是大量的历史数据，基于历史数据我们可以进行「智能识别」和「智能预测」。这个想法很有意思，而且一下子将三个热门领域串起来了，简直太妙了！基于在智能识别领域则有：语音识别、图像识别等等，在智能预测这个方向则有预测系统、个性化推荐等等。&lt;/li&gt;
&lt;li&gt;「机器学习」就是通过算法，使得机器能从大量历史数据中学习规律，从而对新的样本做智能识别或对未来做预测。&lt;/li&gt;
&lt;li&gt;「数据挖掘」也是对大数据的处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;到此，看似玄而又玄的一些领域名词，都能这么轻易的串起来。&lt;/p&gt;
&lt;h4 id=&quot;关于一些学习心得和经历&quot;&gt;&lt;a href=&quot;#关于一些学习心得和经历&quot; class=&quot;headerlink&quot; title=&quot;关于一些学习心得和经历&quot;&gt;&lt;/a&gt;关于一些学习心得和经历&lt;/h4&gt;&lt;p&gt;关于一到三的思考对我的启发性是比较大的，如下：&lt;/p&gt;
&lt;h5 id=&quot;思考一：直觉和自然&quot;&gt;&lt;a href=&quot;#思考一：直觉和自然&quot; class=&quot;headerlink&quot; title=&quot;思考一：直觉和自然&quot;&gt;&lt;/a&gt;思考一：直觉和自然&lt;/h5&gt;&lt;p&gt;表哥说，一切看似很难去理解或者在历史上取得突破性进展的技术，本质上都是很自然的，或者说就是很直觉的东西，对，是「直觉」这个词，换个说法，它的思想是符合正常人思维和直觉的！听起来很抽象对不对，用一个词形容，大道至简也许就明白了。我让表哥举个例子，表哥举例如下，比如云计算：&lt;br&gt;比如有些地方割水稻会有割稻机，一家买一台肯定是不现实的，这个时候就会出现多个人租同一台割稻机，上午割和晚上割可以岔开，这样既节约了开支也避免了资源浪费。这是很简单的思想，资源共享。现在的云平台也是如此，企业都自己搞服务器多浪费，也可能会遇到服务器不够用或者服务器宕机出问题的情况，这个时候有个专门搞云计算的公司公司出来了，比如阿里云，你想要多少服务器我就给你多少，还帮你搞定一切安全性问题。&lt;/p&gt;
&lt;h5 id=&quot;思考二：进去和出来&quot;&gt;&lt;a href=&quot;#思考二：进去和出来&quot; class=&quot;headerlink&quot; title=&quot;思考二：进去和出来&quot;&gt;&lt;/a&gt;思考二：进去和出来&lt;/h5&gt;&lt;p&gt;表哥说，研究任何技术，进去了要出的来。我问怎么理解，当你具体的了解研究了一个技术之后，要能走的出来，然后对它有一个自己的抽象，能从整体上去把握它，不然无法去真正理解。我暂时对此还无法信手拈来，慢慢去理解吧。&lt;/p&gt;
&lt;h5 id=&quot;思考三：眼界和专注&quot;&gt;&lt;a href=&quot;#思考三：眼界和专注&quot; class=&quot;headerlink&quot; title=&quot;思考三：眼界和专注&quot;&gt;&lt;/a&gt;思考三：眼界和专注&lt;/h5&gt;&lt;p&gt;表哥告诫我，一定要将基础的东西弄明白，弄懂，因为他是基础没有为什么，但它仅仅是基础还不够。所以告诉我研究生期间（其实不论在任何时候都是如此，技术领域如此，其他领域也是一样）起码当前行业的技术要知道有哪些，有哪些新的技术发展，然后可以选择一个领域深耕研究。这个我很早以前也深有体会，技术人眼界也很重要，眼界要宽。&lt;/p&gt;
&lt;p&gt;另外还聊了一些其他的话题，比如研究生项目和华为工作的经历：&lt;/p&gt;
&lt;h5 id=&quot;手写编译器&quot;&gt;&lt;a href=&quot;#手写编译器&quot; class=&quot;headerlink&quot; title=&quot;手写编译器&quot;&gt;&lt;/a&gt;手写编译器&lt;/h5&gt;&lt;p&gt;我问表哥研究生期间干了些啥，他说硕士期间做了一个对他影响很大的项目，我好奇问，什么项目？表哥说，大四结束左右时候，曾经为海尔写编译器的项目。。。徒手写编译器——徒手写编译器——徒手写编译器，表示震惊的事说三遍。我问为什么那么大影响，他说，写完编译器，感觉所有的语言在他看来都是表面功夫都是浮云，编译器决定着语言的语法，决定语言的效率。&lt;br&gt;表哥顺势推荐了一本书《深入理解计算机系统》，这本书其实他早前跟我推荐过，有耳闻。他说底层的理解对整个计算机系统的学习有好处，这一点我相信。&lt;/p&gt;
&lt;h5 id=&quot;不做码代码的矮子&quot;&gt;&lt;a href=&quot;#不做码代码的矮子&quot; class=&quot;headerlink&quot; title=&quot;不做码代码的矮子&quot;&gt;&lt;/a&gt;不做码代码的矮子&lt;/h5&gt;&lt;p&gt;华为整体公司分为产品系列和研发系列，研发下面又有四个大机构，中软、中硬和其他两个不记得，表哥是研发系下的中软也就是前面提到的中央软件研究院。我问两大系列有啥区别，表哥说，产品部门更多的是码代码，思考的时间不多。而研发相当于博士期间的的搞研究，必须要发表论文一样。&lt;br&gt;表哥说如果一直码代码，没有思考的时间就会一直很机械，如果在写代码期间有总结心得能提炼独到理解还好，否则很难提高，这个道理不难理解。&lt;/p&gt;
&lt;h5 id=&quot;多动手才是王道&quot;&gt;&lt;a href=&quot;#多动手才是王道&quot; class=&quot;headerlink&quot; title=&quot;多动手才是王道&quot;&gt;&lt;/a&gt;多动手才是王道&lt;/h5&gt;&lt;p&gt;后面聊到了表哥过来招聘的事情，我问表哥面试会问哪些问题，表哥回答说，主要是问研究生期间做了哪些研究，做了哪些事。并建议我有时间多动手做一些东西。&lt;/p&gt;
&lt;h4 id=&quot;最后&quot;&gt;&lt;a href=&quot;#最后&quot; class=&quot;headerlink&quot; title=&quot;最后&quot;&gt;&lt;/a&gt;最后&lt;/h4&gt;&lt;p&gt;与表哥聊天确实让自己感觉到收获不少，尤其是表哥对于问题的思考角度和深度，确实让人有一种新鲜的感觉，「思想」一词被表哥提到很多次，表哥并不是停留技术外在的形式，而是更多关注技术背后所体现的思想和本质的东西，并且又能自然的解释这种技术跟其他技术的关系，这一点是我要学习的。表哥说我最大的特点就是肯钻研，能够真正看得进去，提到自己曾经为了调试一个bug连续两晚调到凌晨。饭间，表哥有两次问到我对计算机的兴趣，其实我心里知道并且清楚，只有爱你所做的，你才能真正做好它，并享受它带给你的快乐。&lt;br&gt;路漫漫，要学习的路程还有很远，希望能够上下求索吧。&lt;br&gt;聊以此文，记录跟表哥的一次谈话。&lt;br&gt;2016年6月26日晚&lt;/p&gt;
&lt;p&gt;-EOF-&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;古人说得好，问渠那得清如许，为有源头活水来。生活中最有趣的事情之一，便是有不断「活水」注入了，这里的活水可以是人，事，也可以是思想和交流。尤其是那些可以给你在学习或者某个领域带来启发性思考的人，今晚便有了这样一次机会。&lt;br&gt;
    
    </summary>
    
      <category term="LifeEssay" scheme="https://zouzls.github.io/categories/LifeEssay/"/>
    
    
      <category term="总结" scheme="https://zouzls.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>2016上半年总结</title>
    <link href="https://zouzls.github.io/2016/06/17/2016%E4%B8%8A%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    <id>https://zouzls.github.io/2016/06/17/2016上半年总结/</id>
    <published>2016-06-17T09:17:31.000Z</published>
    <updated>2016-08-26T10:48:31.202Z</updated>
    
    <content type="html">&lt;p&gt;时间过得太快，转眼间到了2016的年中。自从博客搭起来之后，这个是第一篇总结性的文章。人虽然应该多向前看，但是时常反过来看看自己过去走过的，反思反思，我觉得这样应该是好的。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;通过研究生复试&quot;&gt;&lt;a href=&quot;#通过研究生复试&quot; class=&quot;headerlink&quot; title=&quot;通过研究生复试&quot;&gt;&lt;/a&gt;通过研究生复试&lt;/h4&gt;&lt;p&gt;这个可以是上半年的分水岭了，如若复试折戟，此刻应该早已南下码砖了。但是生活就如同历史一样，来不得假设。凡事没有彻底的好，也没有彻底的坏。总是有太多感谢，感谢所有帮助过我的亲人和朋友，没有你们的帮助，我恐怕会幸苦和艰难很多。&lt;/p&gt;
&lt;h4 id=&quot;开始研究生生活&quot;&gt;&lt;a href=&quot;#开始研究生生活&quot; class=&quot;headerlink&quot; title=&quot;开始研究生生活&quot;&gt;&lt;/a&gt;开始研究生生活&lt;/h4&gt;&lt;h5 id=&quot;项目方面&quot;&gt;&lt;a href=&quot;#项目方面&quot; class=&quot;headerlink&quot; title=&quot;项目方面&quot;&gt;&lt;/a&gt;项目方面&lt;/h5&gt;&lt;p&gt;1、帮助导师完成项目。&lt;br&gt;搞定了几个感觉还比较复杂的功能实现，然后逐渐融入团队和项目开发中，也同时增加了不少自信心。进入任何项目关键还得是找到一个突破口，从这个口子进去了解整个项目的体系，比如这个项目我就是从系统登录入手，从前端控制登录到后端数据库校验，从页面加载到数据获取，包括项目用的是啥框架，业务逻辑如何流转等等，都可以慢慢捋清楚。&lt;/p&gt;
&lt;p&gt;2、完成个人博客的搭建。&lt;br&gt;感谢github提供了page的功能，可以放置静态博客，基本满足对博客的需求。&lt;br&gt;重要的是，完完整整搞定一个项目带来的不仅仅是搞定之后的快感，这中间各种细节问题的解决也是挑战一个程序员解决问题的能力的。&lt;/p&gt;
&lt;p&gt;3、参与github上面的开源项目。&lt;br&gt;虽然目前属于刚刚接触的阶段，但是能感觉到这里面有东西可搞，小小收获如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增加对Git分布式版本控制的了解和运用。&lt;/li&gt;
&lt;li&gt;熟悉github上面代码贡献流程。&lt;br&gt;初学者可以从这个项目入手，&lt;a href=&quot;https://github.com/giantray/stackoverflow-java-top-qa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;stackoverflow精选Java问题翻译&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;后期希望可以在完成导师项目的时候，能发现或者着手实现一个自己的项目，或者加入一个好的开源项目。坚持博客的有效更新。&lt;/p&gt;
&lt;h5 id=&quot;阅读方面&quot;&gt;&lt;a href=&quot;#阅读方面&quot; class=&quot;headerlink&quot; title=&quot;阅读方面&quot;&gt;&lt;/a&gt;阅读方面&lt;/h5&gt;&lt;p&gt;1、&lt;a href=&quot;https://book.douban.com/subject/24722612/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《深入理解Java虚拟机（第2版） : JVM高级特性与最佳实践》&lt;/a&gt;&lt;br&gt;读完。感觉写的还行，澄清了心中的一些疑惑点，有些地方理解还不是很透彻,有时间会多读几遍。&lt;br&gt;2、&lt;a href=&quot;https://book.douban.com/subject/25723064/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《大型网站技术架构 : 核心原理与案例分析》&lt;/a&gt;&lt;br&gt;读完。对于想从宏观上窥视一个大型网站的构架和把一个网站从小到大的如何发展，还是可以一读，挺好的一本书。&lt;br&gt;3、&lt;a href=&quot;https://book.douban.com/subject/10769749/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《推荐系统实践》&lt;/a&gt;&lt;br&gt;在读。公式有点多，没有来得及仔细研究里面的公式，但是写的还是不错，可能自己有点浮躁。&lt;br&gt;下半年希望能在技术领域完成四到五本有效率有质量的阅读，坚持每天沉浸专注阅读的时间争取在2h。&lt;/p&gt;
&lt;h5 id=&quot;体育锻炼&quot;&gt;&lt;a href=&quot;#体育锻炼&quot; class=&quot;headerlink&quot; title=&quot;体育锻炼&quot;&gt;&lt;/a&gt;体育锻炼&lt;/h5&gt;&lt;p&gt;像锻炼身体这个，有个基友跟你一起是再好不过的了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本保持每周都会有一两次体育活动，还不错。&lt;/li&gt;
&lt;li&gt;拓展了网球运动，网球打起来主要是帅！但是像我这种初学菜，额，汗。。。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;坚持每周锻炼，目标是在保持饮食规律合理的情况下，体重减到70kg以下。&lt;/p&gt;
&lt;h5 id=&quot;兴趣爱好&quot;&gt;&lt;a href=&quot;#兴趣爱好&quot; class=&quot;headerlink&quot; title=&quot;兴趣爱好&quot;&gt;&lt;/a&gt;兴趣爱好&lt;/h5&gt;&lt;p&gt;拓展了围棋爱好，哈哈哈。。。有多少今年喜欢围棋的是因为谷歌alphaGo和李世石的人机大战。处于18级别一直上不去。&lt;/p&gt;
&lt;h4 id=&quot;最后&quot;&gt;&lt;a href=&quot;#最后&quot; class=&quot;headerlink&quot; title=&quot;最后&quot;&gt;&lt;/a&gt;最后&lt;/h4&gt;&lt;p&gt;身体是革命的本钱，希望对于身体的锻炼能够永远坚持下去！&lt;br&gt;希望时间不被虚度，保持谦卑进取的心。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;时间过得太快，转眼间到了2016的年中。自从博客搭起来之后，这个是第一篇总结性的文章。人虽然应该多向前看，但是时常反过来看看自己过去走过的，反思反思，我觉得这样应该是好的。&lt;br&gt;
    
    </summary>
    
      <category term="LifeEssay" scheme="https://zouzls.github.io/categories/LifeEssay/"/>
    
    
      <category term="总结" scheme="https://zouzls.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>朝花夕拾之重回母校</title>
    <link href="https://zouzls.github.io/2016/06/17/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE%E4%B9%8B%E9%87%8D%E5%9B%9E%E6%AF%8D%E6%A0%A1/"/>
    <id>https://zouzls.github.io/2016/06/17/朝花夕拾之重回母校/</id>
    <published>2016-06-17T08:31:56.000Z</published>
    <updated>2016-08-26T10:48:30.520Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://oaewlsdmg.bkt.clouddn.com/blog/image/6c552bfc0fe89e23.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;很少写文章，也不知从哪写起，前两天趁着端午回了趟母校，跟之前带过的学弟学妹一起度过了毕业时光中难得的两天。六月七八号，桂林的夏天依旧炎热的不行，但是骄阳下的桂电，依然是当年的模样。只是毕业两年后再次踏入校园，那种感觉就像是故人重逢，无论时隔多久，就好像是一切的事情刚刚发生在昨天。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;华仔火锅店&quot;&gt;&lt;a href=&quot;#华仔火锅店&quot; class=&quot;headerlink&quot; title=&quot;华仔火锅店&quot;&gt;&lt;/a&gt;华仔火锅店&lt;/h4&gt;&lt;p&gt;当年宿舍经常吃狗肉的华仔火锅店，老板娘还是浑身洋溢着热情，跟学弟学妹在那吃饭的晚上，往事还是一幕幕，我毕竟是个易怀旧的人，老板娘当年在生日赠我的一碗长寿面，如今还是被我跟身边的人乐道不止。那晚醉的不行，大吐不止。被扶着走进校园，去了田径场。像往常一样，路过三教，穿过二教研究生院，穿过体育馆，那边以前经常贴着无数的小广告和路边的桂花树，在我半醉半醒之间，徐徐向我走来。&lt;/p&gt;
&lt;h4 id=&quot;田径场&quot;&gt;&lt;a href=&quot;#田径场&quot; class=&quot;headerlink&quot; title=&quot;田径场&quot;&gt;&lt;/a&gt;田径场&lt;/h4&gt;&lt;p&gt;操场，田径场。这个在我大学时代发生了无数太多故事的地方，也一定是盛满了所有桂电东区人回忆的一个地方。作为我曾经爱情的发源地，曾经一个月坚持跑步的历史，估计在未来很长的一个时期内，都不会被我改写。我看着你，齐肩的短发变成长发，你粉红色的T恤开始演变长裙短裙，你穿着白蓝相间的安踏运动鞋不经意之间换上了高跟，我跟你说，月亮是我送你的礼物，树叶的积累是我们美好心情的见证。&lt;br&gt;&lt;img src=&quot;http://oaewlsdmg.bkt.clouddn.com/blog%2Fimage%2F1449485047598.jpeg&quot; alt=&quot;&quot;&gt;&lt;br&gt;万物之中，希望至美；至美之物，永不凋零。&lt;br&gt;希望至美的东西永远在我们心中，希望致橡树在你读来，依然是温柔如玉，希望在你跑完1Km长跑的结束，在你大汗淋漓的时候，我仍旧可以为你送上一杯可口的凉饮，看着你气喘吁吁的样子，满心欢喜。&lt;/p&gt;
&lt;h4 id=&quot;一点感想&quot;&gt;&lt;a href=&quot;#一点感想&quot; class=&quot;headerlink&quot; title=&quot;一点感想&quot;&gt;&lt;/a&gt;一点感想&lt;/h4&gt;&lt;p&gt;两年之后，再次坐在田径场上，只是身边围着坐着的，是一群即将毕业的孩子。他们无法体会我现在的心情，就像我当初无法理解毕业一年之久，也渴望回到校园的师兄学长，我唯有祝你们毕业快乐，一切顺利。有些事情你注定只有自己亲历，才能亲身体会感受。&lt;/p&gt;
&lt;p&gt;那天晚上，我记得自己没讲什么，只讲了一些过来人从大学到毕业两年的切身感受，也许那晚微醺的学弟学妹并不曾记住，但也无妨。大概意思是，「人的一生中有很多你想要追求的，也许一次会失败，但是不要怕，最简单的方法就是，再试一次」。朴实的不能再朴实的道理，但是在如今众多的能让人热血澎湃的鸡汤里面，确实不会引起太大的共鸣，毕竟肯再试一次的太少，最终都成了「你所追求的东西不适合你」，这样一个伪命题。&lt;/p&gt;
&lt;h4 id=&quot;最后&quot;&gt;&lt;a href=&quot;#最后&quot; class=&quot;headerlink&quot; title=&quot;最后&quot;&gt;&lt;/a&gt;最后&lt;/h4&gt;&lt;p&gt;我坐上了唯一大学毕业留在桂林的大学室友的电动车去往了他的住处，两个老男和一群即将离校的鲜肉的田径场聚会在歌声和舞蹈中结束，他们应该知道那会是他们最后一次这样席地而坐，在当晚明亮的月光下，见证他们大学时代最后屈指可数的日子里难得的欢宴和畅谈。&lt;/p&gt;
&lt;p&gt;-EOF-&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oaewlsdmg.bkt.clouddn.com/blog/image/6c552bfc0fe89e23.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;很少写文章，也不知从哪写起，前两天趁着端午回了趟母校，跟之前带过的学弟学妹一起度过了毕业时光中难得的两天。六月七八号，桂林的夏天依旧炎热的不行，但是骄阳下的桂电，依然是当年的模样。只是毕业两年后再次踏入校园，那种感觉就像是故人重逢，无论时隔多久，就好像是一切的事情刚刚发生在昨天。&lt;br&gt;
    
    </summary>
    
      <category term="LifeEssay" scheme="https://zouzls.github.io/categories/LifeEssay/"/>
    
    
      <category term="重返母校" scheme="https://zouzls.github.io/tags/%E9%87%8D%E8%BF%94%E6%AF%8D%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>How do servlets work? Instantiation, shared variables and multithreading</title>
    <link href="https://zouzls.github.io/2016/06/17/how-do-servlets-work-instantiation/"/>
    <id>https://zouzls.github.io/2016/06/17/how-do-servlets-work-instantiation/</id>
    <published>2016-06-17T06:23:51.000Z</published>
    <updated>2016-07-28T01:30:45.598Z</updated>
    
    <content type="html">&lt;h3 id=&quot;问题：&quot;&gt;&lt;a href=&quot;#问题：&quot; class=&quot;headerlink&quot; title=&quot;问题：&quot;&gt;&lt;/a&gt;问题：&lt;/h3&gt;&lt;p&gt;假设，我有一个web服务器可以支持无数的servlets，对于通过这些servlets的信息，我正在获取这些servlets的上下文环境，并设置session变量。&lt;br&gt;现在，如果有两个或者更多的user用户发送请求到这个服务器，session变量会发生什么变化？session对于所有的user是公共的还是不同的user拥有不同的session。如果用户彼此之间的session是不同的，那么服务器怎么区分辨别不同的用户呢？&lt;br&gt;另外一些相似的问题，如果有N个用户访问一个具体的servlets，那么这个servlets是只在第一个用户第一次访问的时候实例化，还是为每一个用户各自实例化呢？&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;答案：&quot;&gt;&lt;a href=&quot;#答案：&quot; class=&quot;headerlink&quot; title=&quot;答案：&quot;&gt;&lt;/a&gt;答案：&lt;/h3&gt;&lt;h4 id=&quot;ServletContext&quot;&gt;&lt;a href=&quot;#ServletContext&quot; class=&quot;headerlink&quot; title=&quot;ServletContext&quot;&gt;&lt;/a&gt;ServletContext&lt;/h4&gt;&lt;p&gt;当servletcontainer（像tomcat）启动的时候，它会部署和加载所有的webapplications，当一个webapplication加载完成后，servletcontainer就会创建一个ServletContext，并且保存在服务器的内存中。这个webapp的web.xml会被解析，web.xml中的每个servlet, filter 和 listener或者通过注解@WebServlet, @WebFilter and @WebListener，都会被创建一次并且也保存在服务器的内存中。对于所有filter，init()方法会被直接触发，当servletcontainer关闭的时候，它会unload所有的webapplications,触发所有实例化的servlets和filters的destroy()方法,最后，servletcontext和所有的servlets，filter和listener实例都会被销毁。&lt;/p&gt;
&lt;h4 id=&quot;HttpServletRequest-and-HttpServletResponse&quot;&gt;&lt;a href=&quot;#HttpServletRequest-and-HttpServletResponse&quot; class=&quot;headerlink&quot; title=&quot;HttpServletRequest and HttpServletResponse&quot;&gt;&lt;/a&gt;HttpServletRequest and HttpServletResponse&lt;/h4&gt;&lt;p&gt;servletcontainer 是附属于webserver的，而这个webserver会持续监听一个目标端口的HTTP request请求，这个端口在开发中经常会被设置成8080，而在生产环境会被设置成80。当一个客户端（比如用户的浏览器）发送一个HTTP request，servletcontainer就会创建新的HttpServletRequest对象和HttpServletResponse对象。。。。&lt;/p&gt;
&lt;p&gt;在有filter的情况下，doFilter()方法会被触发。当代码调用chain.doFilter(request, response)时候，请求会经过下一个过滤器filter，如果没有了过滤器，会到达servlet。在servlets的情况下，service()触发，然后根据request.getMethod()确定执行doGet()还是doPost()，如果当前servlet找不到请求的方法，返回405error。&lt;/p&gt;
&lt;p&gt;request对象提供了HTTP请求所有的信息，比如request headers和request body，response对象提供了控制和发送HTTP响应的的能力，并且以你想要的方式，比如设置headers和body。当HTTP响应结束，请求和响应对象会被销毁（实际上，大多数container将会清洗到这些对象的状态然后回收这些事例以重新利用）&lt;/p&gt;
&lt;h4 id=&quot;httpSession&quot;&gt;&lt;a href=&quot;#httpSession&quot; class=&quot;headerlink&quot; title=&quot;httpSession&quot;&gt;&lt;/a&gt;httpSession&lt;/h4&gt;&lt;p&gt;当客户端第一次访问webapp或者通过request.getSession()方法第一次获取httpSession&lt;br&gt;，servletcontainer 将会创建一个新的HttpSession 对象，产生一个长的唯一的ID标记session（可以通过session.getId()）,并且将这个session存储在server内存中。servletcontainer 同时会在HTTP response的Header中设置Set-Cookie值，其中cookie name为JSESSIONID，cookie value为唯一的长ID值。&lt;/p&gt;
&lt;p&gt;在接下来的连续请求中，客户端浏览器都要cookie通过header带回，然后servletcontainer 会根据cookie中的JSESSIONID 值，获得server内存中的对应的httpSession。&lt;/p&gt;
&lt;p&gt;只要没超过session-timeout设定的值，httpSession对象会一直存在，session-timeout大小可以在web.xml中设定，默认是30分钟。所以如果连续30分钟之内客户端不再访问webapp，servletcontainer就会销毁对应的session。接下来的request请求即使cookies依旧存在，但是却不再有对应的session了。servletcontainer 会创建新的session。&lt;/p&gt;
&lt;p&gt;另外一方面，session cookie在浏览器端有默认的生命时长，就是只要浏览器一直在运行，所以当浏览器关闭，浏览器端的cookie会被销毁。&lt;/p&gt;
&lt;h4 id=&quot;最后&quot;&gt;&lt;a href=&quot;#最后&quot; class=&quot;headerlink&quot; title=&quot;最后&quot;&gt;&lt;/a&gt;最后&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;只要webapp存在，ServletContext 一定会存在。并且ServletContext 是被所有session和request共享的。&lt;/li&gt;
&lt;li&gt;只要客户端用同一个浏览器和webapp交互并且该session没有在服务端超时，HttpSession 就会一直存在。并且在同一个会话中所有请求都是共享的。&lt;/li&gt;
&lt;li&gt;只有当完整的response响应到达，HttpServletRequest 和 HttpServletResponse才不再存活，并且不被共享。&lt;/li&gt;
&lt;li&gt;只要webapp存在，servlet、filter和listener就会存在。他们被所有请求和会话共享。&lt;/li&gt;
&lt;li&gt;只要问题中的对象存在，任何设置在ServletContext, HttpServletRequest 和 HttpSession中的属性就会存在。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;线程安全&quot;&gt;&lt;a href=&quot;#线程安全&quot; class=&quot;headerlink&quot; title=&quot;线程安全&quot;&gt;&lt;/a&gt;线程安全&lt;/h4&gt;&lt;p&gt;就是说，你主要关注的是线程安全性。你应该了解到，servlets和filter是被所有请求共享的。这正是Java的美妙之处，它的多线程和不同的线程可以充分利用同样的实例instance，否则对于每一个request请求都要重复创建和调用init()和destroy()开销太大。&lt;/p&gt;
&lt;p&gt;但是你也应该注意到，你不应该把任何请求或会话作用域的数据作为一个servlet或过滤器的实例变量。这样会被其他会话的请求共享，并且那是线程不安全的！下面的例子阐明的这点：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ExampleServlet&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HttpServlet&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Object thisIsNOTThreadSafe;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;doGet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(HttpServletRequest request, HttpServletResponse response)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; ServletException, IOException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Object thisIsThreadSafe;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        thisIsNOTThreadSafe = request.getParameter(&lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// BAD!! Shared among all requests!&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        thisIsThreadSafe = request.getParameter(&lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// OK, this is thread safe.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;原答案stackoverflow链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/3106452/how-do-servlets-work-instantiation-shared-variables-and-multithreading&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://stackoverflow.com/questions/3106452/how-do-servlets-work-instantiation-shared-variables-and-multithreading&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;-EOF-&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题：&quot;&gt;&lt;a href=&quot;#问题：&quot; class=&quot;headerlink&quot; title=&quot;问题：&quot;&gt;&lt;/a&gt;问题：&lt;/h3&gt;&lt;p&gt;假设，我有一个web服务器可以支持无数的servlets，对于通过这些servlets的信息，我正在获取这些servlets的上下文环境，并设置session变量。&lt;br&gt;现在，如果有两个或者更多的user用户发送请求到这个服务器，session变量会发生什么变化？session对于所有的user是公共的还是不同的user拥有不同的session。如果用户彼此之间的session是不同的，那么服务器怎么区分辨别不同的用户呢？&lt;br&gt;另外一些相似的问题，如果有N个用户访问一个具体的servlets，那么这个servlets是只在第一个用户第一次访问的时候实例化，还是为每一个用户各自实例化呢？&lt;br&gt;
    
    </summary>
    
      <category term="Javaweb" scheme="https://zouzls.github.io/categories/Javaweb/"/>
    
    
      <category term="servlet" scheme="https://zouzls.github.io/tags/servlet/"/>
    
  </entry>
  
  <entry>
    <title>用Hexo搭建个人博客</title>
    <link href="https://zouzls.github.io/2016/04/21/%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://zouzls.github.io/2016/04/21/用hexo搭建个人博客/</id>
    <published>2016-04-21T15:26:12.000Z</published>
    <updated>2016-07-16T03:57:18.795Z</updated>
    
    <content type="html">&lt;p&gt;从很久之前就想要有一个属于自己的博客，如果互联网是一个世界的话，一个有着自己独特域名的博客应该就是在这个世界里面的自己的家吧。由于毕业后工作，后来又忙着考研，这个简单的愿望一直搁浅。&lt;br&gt;现在趁着有闲暇的精力，终于把这个一拖再拖的事情给实现，搭建过程总体是简单的，没有费多少力气，但是还是遇到了一些小问题，现在将遇到的问题记录下来。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;关于博客源码的备份和同步更新&quot;&gt;&lt;a href=&quot;#关于博客源码的备份和同步更新&quot; class=&quot;headerlink&quot; title=&quot;关于博客源码的备份和同步更新&quot;&gt;&lt;/a&gt;关于博客源码的备份和同步更新&lt;/h3&gt;&lt;h4 id=&quot;方案选择&quot;&gt;&lt;a href=&quot;#方案选择&quot; class=&quot;headerlink&quot; title=&quot;方案选择&quot;&gt;&lt;/a&gt;方案选择&lt;/h4&gt;&lt;p&gt;这个让我费时不少，因为考虑到有时候在自己笔记本上更新博客，有时候在实验室电脑上更新，这个时候问题就出现了。其一，不可能每次带U盘copy，其二，如果用百度云或者Dropbox这类云盘，感觉总是有些麻烦的。&lt;br&gt;所以还是考虑用github 存放源码，但是有遇到两个选择：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种方案是重新开一个repo，这样一个repo放博客生成的静态文件，另外一个repo专门放博客源码。&lt;/li&gt;
&lt;li&gt;另外一种方案是一个repo开两个分支，其中一个master分支主要放静态文件，另外一个分支（自己命名）hexo，专门放博客源码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一种方案总感觉冗余，而第二种看起来更加简洁干净（操作起来也遇到了不少麻烦），最终还是选择第二种方案。&lt;/p&gt;
&lt;h4 id=&quot;出现问题&quot;&gt;&lt;a href=&quot;#出现问题&quot; class=&quot;headerlink&quot; title=&quot;出现问题&quot;&gt;&lt;/a&gt;出现问题&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;问题描述&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为我是先在本地&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git init &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git add origin &amp;lt;server&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;初始化本地文件夹，然后&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git add .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git commit -m &amp;quot;description&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git push origin hexo&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;最后一步失败。尝试过git pull命令、并将hexo分支文件清空，然而都无济于事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解决问题：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;删掉这个库zouzls.github.io,然后重新新建，开两个分支，并设置hexo默认分支，此时两个分支为空。&lt;br&gt;在本地新建一个文件夹，git clone server地址,然后copy原来的博客站文件过来当前文件夹，运行下列命令：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git add .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git commit -m &amp;quot;description&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git push origin hexo&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后解决问题，博客源码推送到hexo分支，再在新的电脑将源码clone下来就OK了，前提是已经安装有git、nodejs、hexo。至于由博客生成的静态html文件如何放到master分支，网上太多教程就不详述了。&lt;/p&gt;
&lt;h3 id=&quot;最后&quot;&gt;&lt;a href=&quot;#最后&quot; class=&quot;headerlink&quot; title=&quot;最后&quot;&gt;&lt;/a&gt;最后&lt;/h3&gt;&lt;p&gt;人生有涯，知也无涯。&lt;br&gt;坚持学习，保持好奇心。&lt;br&gt;坚持锻炼身体。&lt;/p&gt;
&lt;p&gt;-EOF-&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;从很久之前就想要有一个属于自己的博客，如果互联网是一个世界的话，一个有着自己独特域名的博客应该就是在这个世界里面的自己的家吧。由于毕业后工作，后来又忙着考研，这个简单的愿望一直搁浅。&lt;br&gt;现在趁着有闲暇的精力，终于把这个一拖再拖的事情给实现，搭建过程总体是简单的，没有费多少力气，但是还是遇到了一些小问题，现在将遇到的问题记录下来。&lt;br&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://zouzls.github.io/categories/Hexo/"/>
    
    
      <category term="blog" scheme="https://zouzls.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>朝花夕拾之论纸老虎</title>
    <link href="https://zouzls.github.io/2014/04/20/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE%E4%B9%8B%E8%AE%BA%E7%BA%B8%E8%80%81%E8%99%8E/"/>
    <id>https://zouzls.github.io/2014/04/20/朝花夕拾之论纸老虎/</id>
    <published>2014-04-20T12:31:22.000Z</published>
    <updated>2016-08-26T10:48:29.110Z</updated>
    
    <content type="html">&lt;p&gt;一切的困难都是纸老虎，本来不想用这么斩金截铁的语气，但是实在是想说，人一生都会遇到很多的困难，其实吓倒你的不是困难而是你自己。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;2013年初，在面临考验专业选择百无聊奈之际，经过经济学、统计学、管理科学与工程等等各种纠结之后，毅然选择了曾经因为困难而差点被放弃的计算机科学与工程，选择之后，连我自己都差点不相信这个决定，我清楚的记得当时的日子，历经三天的说服自己，我在5月3号去旧书店买了专业课的四本书《操作系统》、《计算机组成原理》和《数据结构》，另外一本《计算机网络》是跟同学借的，脑海中清晰的记得踏上这条路的所受的第一个鼓励，来自旧书店老板，书店老板定眼看了我半分钟，说，“男孩子学工科还是比较有前途的，不错不错。。。”，当时出来的时候，我笑了。&lt;/p&gt;
&lt;p&gt;于是经过深思熟虑之后，坚决了走向这条其他人看起来不可思议的路，身边人的异样的眼神中反而增强了我的信念，朋友在一起聊天说，“你这个希望太渺茫了，我给你10%的概率逆袭。。。”，我笑着应付，我从小就有一种信念，觉得“nothing is impossible ！”，别人行的，我也行！其实更重要的激励自己是心中对计算机行业的热爱，那种对知识的无穷的渴望，对几十年计算机人智慧的热爱，作为一个身上流淌着理科生血液的人，这种情感在我后面不断的学习当中深刻，有时真是恨不能CS出身。&lt;/p&gt;
&lt;p&gt;现在仍然记得当时在外租房子，每天晚上看书看到凌晨一点半，刚开始看视频学习郝斌老师的《数据结构》和刘子良老师的《计算机组成原理》也是动不动就是两点多睡觉，这种日子至今难忘。听不懂的时候，觉得太难了，这连本科生的水平都达不到，怎么能应付考研，想想当时难过极了，我自己一向是不喜欢抱怨说某件事难，既然选择了便要一直走下去。。。那段时间也经常看经验贴，一些过来人的经验和鼓励也是不断的激励我，想想真是多亏了他们，如果没有过来人的榜样，说不定我也没有勇气选择计算机，互联网在沟通与交流的作用真是改变了人类文明的进步，包括在资源共享上得到的福利，更是让我感谢互联网的带来的巨大的好处。&lt;/p&gt;
&lt;p&gt;挑灯夜读的画面会始终浮现在脑海中，那种不断的获取新知识，追求所爱的热情真是能融化一切。上帝的考验终于在一步步的努力下有了回报，四本书总算被我一点点啃下来了，《机组》的晦涩难懂但是融合了一代代人的智慧的结晶，DS中算法的奥妙无穷使再难的问题终究有一个解决的方法而且万变不离其宗，OS稍简单，则蕴涵管理方法之精妙，《计算机网络》各种协议层出不穷，我也只能参透其中一半。。。历经千山万水，终于摸到了一点门道，至于对付考研仍旧是心有余悸，但自己是已尽人事，只能听天由命了，上帝待我不薄，从最初的的忐忑不安到现在的心态平和，从年初的五月份到年终的十二月份，我用八个月的时间完成了对计算机的懵懂无知到胸中已有大概，至少我这一年没有白忙活，学习了自己喜欢的新知识，好不高兴！&lt;/p&gt;
&lt;p&gt;我带着这份平静走上了考场，完成了四张试卷，写完了自己会写了，无憾。年初成绩出来，初试分数高出目标院校分数线16分，对于这样的成绩，想想真是满足了，当年窃以为不可跨越的困难终究跨过来了，真是感谢上帝眷顾！&lt;/p&gt;
&lt;p&gt;为什么选择用“纸老虎”来做文章题目，相必这儿已经有了最好答案，考研半载的经历对于笔者日后的生活将宝贵无比，敢于将一切困难化成纸老虎和能将一切困难化成纸老虎，确实是需要慢慢锻炼慢慢体会的，但我想冷静、勇气与执着，三者一定是不可缺少的，而这过程中的一切以及事成之后的痛快，将会让人一生受益无穷！&lt;/p&gt;
&lt;p&gt;题外话，犹记得读DSDN上面的一篇博文一位博主引用的对幸福的理解：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;幸福是什么&lt;br&gt;1、做自己喜欢做的。&lt;br&gt;2、用自己喜欢做的养活自己。&lt;br&gt;3、在自己喜欢做的事上有所成就。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;-EOF-&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;一切的困难都是纸老虎，本来不想用这么斩金截铁的语气，但是实在是想说，人一生都会遇到很多的困难，其实吓倒你的不是困难而是你自己。&lt;br&gt;
    
    </summary>
    
      <category term="LifeEssay" scheme="https://zouzls.github.io/categories/LifeEssay/"/>
    
    
      <category term="一战考研" scheme="https://zouzls.github.io/tags/%E4%B8%80%E6%88%98%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
</feed>
